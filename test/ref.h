// Generated by schema_gen from ref.hischema
#ifndef GEN__H_INCLUDE
#define GEN__H_INCLUDE

// To create the implementation, define GEN__IMPLEMENTATION before including this file in one translation unit.

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef GEN__API
#  ifdef GEN__STATIC
#    define GEN__API static
#  else
#    define GEN__API extern
#  endif
#endif

#ifndef GEN_DEPRECATED
#  if defined(__GNUC__) || defined(__clang__)
#    define GEN_DEPRECATED(msg) __attribute__((deprecated(msg)))
#  else
#    define GEN_DEPRECATED(msg)
#  endif
#endif

#if defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#  define gen__IS_BIG_ENDIAN 1
#elif defined(__BIG_ENDIAN__)
#  define gen__IS_BIG_ENDIAN 1
#else
#  define gen__IS_BIG_ENDIAN 0
#endif

#if gen__IS_BIG_ENDIAN
#  ifdef _MSC_VER
#    include <stdlib.h>
#    define gen__bswap16(x) _byteswap_ushort(x)
#    define gen__bswap32(x) _byteswap_ulong(x)
#    define gen__bswap64(x) _byteswap_uint64(x)
#  elif defined(__GNUC__) || defined(__clang__)
#    define gen__bswap16(x) __builtin_bswap16(x)
#    define gen__bswap32(x) __builtin_bswap32(x)
#    define gen__bswap64(x) __builtin_bswap64(x)
#  else
     static inline uint16_t gen__bswap16(uint16_t x) { return (x >> 8) | (x << 8); }
     static inline uint32_t gen__bswap32(uint32_t x) { return ((x >> 24) & 0xff) | ((x >> 8) & 0xff00) | ((x << 8) & 0xff0000) | ((x << 24) & 0xff000000); }
     static inline uint64_t gen__bswap64(uint64_t x) { return ((x >> 56) & 0xff) | ((x >> 40) & 0xff00) | ((x >> 24) & 0xff0000) | ((x >> 8) & 0xff000000) | ((x << 8) & 0xff00000000) | ((x << 24) & 0xff0000000000) | ((x << 40) & 0xff000000000000) | ((x << 56) & 0xff00000000000000); }
#  endif
#endif

typedef struct gen_Buffer {
    void *ptr;
    uint32_t size;
    uint32_t used;
} gen_Buffer;

typedef struct gen_SchemaInfo gen_SchemaInfo;

GEN__API void gen_buffer_init(gen_Buffer *buffer, void *ptr, uint32_t size);
typedef enum gen_WireType {
    gen_WireType_Varint = 0,
    gen_WireType_Fixed32 = 1,
    gen_WireType_Fixed64 = 2,
    gen_WireType_LengthDelimited = 3,
} gen_WireType;

typedef struct gen_Achievements gen_Achievements;
typedef struct gen_PlayerState gen_PlayerState;
typedef struct gen_Player gen_Player;

typedef struct gen_ArrayAchievements gen_ArrayAchievements;

typedef enum gen_Class {
    gen_Class_fighter = 0,
    gen_Class_mage = 1,
    gen_Class_summoner = 2,
} gen_Class;

struct gen_ArrayAchievements {
    gen_Achievements *items;
    uint32_t count;
};

struct gen_Achievements {
    uint8_t red;
    uint8_t green;
    uint8_t blue;
    uint8_t alpha;
};

struct gen_PlayerState {
    bool has_yaw;
    u32 yaw : 10;
    bool has_posX;
    i32 posX : 20;
    bool has_posY;
    i32 posY : 20;
    bool has_posZ;
    i32 posZ : 20;
};

struct gen_Player {
    bool has_id;
    u32 id;
    bool has_class;
    gen_Class class;
    bool has_colors;
    gen_ArrayAchievements colors;
};

GEN__API bool gen_ArrayAchievements_read(gen_ArrayAchievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_ArrayAchievements_write(const gen_ArrayAchievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievements_read(gen_Achievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievements_write(const gen_Achievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_PlayerState_read(gen_PlayerState *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_PlayerState_write(const gen_PlayerState *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_read(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_write(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);

GEN__API void gen_Achievements_defaults(gen_Achievements *value);
GEN__API void gen_PlayerState_defaults(gen_PlayerState *value);
GEN__API void gen_Player_defaults(gen_Player *value);

typedef enum gen_type {
    gen_type_u8,
    gen_type_u16,
    gen_type_u32,
    gen_type_u64,
    gen_type_i8,
    gen_type_i16,
    gen_type_i32,
    gen_type_i64,
    gen_type_f32,
    gen_type_f64,
    gen_type_bool,
    gen_type_Class,
    gen_type_Achievements,
    gen_type_PlayerState,
    gen_type_Player,
    gen_type_ArrayAchievements,
} gen_type;

typedef struct gen_ParameterInfo {
    const char *name;
    uint32_t parameter_id;
    gen_type type_id;
    uint32_t offset;
} gen_ParameterInfo;

typedef struct gen_TypeDescription {
    const char *name;
    gen_type type_id;
    size_t struct_size;
    size_t no_padding_struct_size;
    const gen_ParameterInfo *parameters;
    uint32_t parameter_count;
} gen_TypeDescription;

typedef enum gen_achievementsParameters {
    gen_achievementsParameters_red = 0,
    gen_achievementsParameters_green = 1,
    gen_achievementsParameters_blue = 2,
    gen_achievementsParameters_alpha = 3,
} gen_achievementsParameters;

typedef enum gen_playerStateParameters {
    gen_playerStateParameters_yaw = 0,
    gen_playerStateParameters_posX = 1,
    gen_playerStateParameters_posY = 2,
    gen_playerStateParameters_posZ = 3,
} gen_playerStateParameters;

typedef enum gen_playerParameters {
    gen_playerParameters_id = 1,
    gen_playerParameters_class = 2,
    gen_playerParameters_colors = 3,
} gen_playerParameters;

GEN__API const gen_TypeDescription *gen_get_type_description(gen_type type_id);
GEN__API bool gen_Achievements_encode_compact(const gen_Achievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievements_decode_compact(gen_Achievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievements_skip_compact(gen_Buffer *buffer);

GEN__API bool gen_PlayerState_encode_compact(const gen_PlayerState *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_PlayerState_decode_compact(gen_PlayerState *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_PlayerState_skip_compact(gen_Buffer *buffer);

GEN__API bool gen_Player_encode_compact(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_decode_compact(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_skip_compact(gen_Buffer *buffer);

typedef struct gen_SchemaField {
    const char *name;
    uint32_t id;
    uint32_t type_id;
    bool is_array;
    bool is_optional;
    bool is_deprecated;
    int32_t mapping;
} gen_SchemaField;

typedef struct gen_SchemaType {
    const char *name;
    uint8_t kind; // 0=ENUM, 1=STRUCT, 2=MESSAGE
    uint32_t type_id;
    gen_SchemaField *fields;
    uint32_t field_count;
} gen_SchemaType;

struct gen_SchemaInfo {
    uint8_t version;
    gen_SchemaType *types;
    uint32_t type_count;
};

GEN__API const gen_SchemaInfo *gen_parse_schema(const uint8_t *data, size_t size, gen_Buffer *allocator);
GEN__API const uint8_t *gen_get_schema_blob(size_t *out_size);
GEN__API const gen_SchemaInfo *gen_get_embedded_schema(gen_Buffer *allocator);
GEN__API bool gen_skip_generic(gen_Buffer *buffer, uint32_t type_id, bool is_array, const gen_SchemaInfo *schema);
#ifdef __cplusplus
}
#endif

#endif /* GEN__H_INCLUDE */

#ifdef GEN__IMPLEMENTATION

void gen_buffer_init(gen_Buffer *buffer, void *ptr, uint32_t size) {
    buffer->ptr = ptr;
    buffer->size = size;
    buffer->used = 0;
}

bool gen_buffer_read_bytes(gen_Buffer *buffer, void *dst, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    const uint8_t *base = (const uint8_t *)buffer->ptr;
    memcpy(dst, base + buffer->used, len);
    buffer->used += (uint32_t)len;
    return true;
}

bool gen_buffer_write_bytes(gen_Buffer *buffer, const void *src, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    uint8_t *base = (uint8_t *)buffer->ptr;
    memcpy(base + buffer->used, src, len);
    buffer->used += (uint32_t)len;
    return true;
}

size_t gen_buffer_align_forward(size_t value, size_t alignment) {
    if (alignment < sizeof(void *)) { alignment = sizeof(void *); }
    size_t remainder = value % alignment;
    if (remainder) { value += alignment - remainder; }
    return value;
}

void *gen_buffer_push_aligned(gen_Buffer *buffer, size_t len, size_t alignment) {
    if (!buffer) { return NULL; }
    size_t offset = gen_buffer_align_forward((size_t)buffer->used, alignment);
    size_t end = offset + len;
    if (end > (size_t)buffer->size) { return NULL; }
    uint8_t *base = (uint8_t *)buffer->ptr;
    void *ptr = base + offset;
    buffer->used = (uint32_t)end;
    return ptr;
}

bool gen_buffer_pop_to(gen_Buffer *buffer, uint32_t marker) {
    if (!buffer) { return false; }
    if (marker > buffer->used) { return false; }
    buffer->used = marker;
    return true;
}

bool gen_buffer_read_u8(gen_Buffer *buffer, uint8_t *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_u8(gen_Buffer *buffer, const uint8_t value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_u16(gen_Buffer *buffer, uint16_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (uint16_t)gen__bswap16((uint16_t)*out);
#endif
    return true;
}
bool gen_buffer_write_u16(gen_Buffer *buffer, const uint16_t value) {
#if gen__IS_BIG_ENDIAN
    uint16_t swapped = (uint16_t)gen__bswap16((uint16_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_u32(gen_Buffer *buffer, u32 *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_u32(gen_Buffer *buffer, const u32 value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_u64(gen_Buffer *buffer, uint64_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (uint64_t)gen__bswap64((uint64_t)*out);
#endif
    return true;
}
bool gen_buffer_write_u64(gen_Buffer *buffer, const uint64_t value) {
#if gen__IS_BIG_ENDIAN
    uint64_t swapped = (uint64_t)gen__bswap64((uint64_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_i8(gen_Buffer *buffer, int8_t *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_i8(gen_Buffer *buffer, const int8_t value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_i16(gen_Buffer *buffer, int16_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (int16_t)gen__bswap16((uint16_t)*out);
#endif
    return true;
}
bool gen_buffer_write_i16(gen_Buffer *buffer, const int16_t value) {
#if gen__IS_BIG_ENDIAN
    int16_t swapped = (int16_t)gen__bswap16((uint16_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_i32(gen_Buffer *buffer, i32 *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_i32(gen_Buffer *buffer, const i32 value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_i64(gen_Buffer *buffer, int64_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (int64_t)gen__bswap64((uint64_t)*out);
#endif
    return true;
}
bool gen_buffer_write_i64(gen_Buffer *buffer, const int64_t value) {
#if gen__IS_BIG_ENDIAN
    int64_t swapped = (int64_t)gen__bswap64((uint64_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_f32(gen_Buffer *buffer, f32 *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_f32(gen_Buffer *buffer, const f32 value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_f64(gen_Buffer *buffer, double *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_f64(gen_Buffer *buffer, const double value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_bool(gen_Buffer *buffer, bool *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_bool(gen_Buffer *buffer, const bool value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_skip_bytes(gen_Buffer *buffer, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    buffer->used += (uint32_t)len;
    return true;
}

uint32_t gen_encode_var_u32_raw(uint32_t value, uint8_t out[5]) {
    uint32_t count = 0;
    do {
        uint8_t byte = (uint8_t)(value & 0x7Fu);
        value >>= 7u;
        if (value) { byte |= 0x80u; }
        out[count++] = byte;
    } while (value);
    return count;
}

bool gen_buffer_begin_block(gen_Buffer *buffer, uint32_t *marker) {
    if (buffer->used + 5 > buffer->size) { return false; }
    uint8_t *base = (uint8_t *)buffer->ptr;
    memset(base + buffer->used, 0, 5);
    *marker = buffer->used;
    buffer->used += 5;
    return true;
}

bool gen_buffer_end_block(gen_Buffer *buffer, uint32_t marker) {
    uint32_t payload_start = marker + 5;
    if (buffer->used < payload_start) { return false; }
    uint32_t payload_len = buffer->used - payload_start;
    uint8_t encoded[5];
    uint32_t encoded_len = gen_encode_var_u32_raw(payload_len, encoded);
    uint8_t *base = (uint8_t *)buffer->ptr;
    memmove(base + marker + encoded_len, base + payload_start, payload_len);
    memcpy(base + marker, encoded, encoded_len);
    buffer->used = marker + encoded_len + payload_len;
    return true;
}

bool gen_write_var_u32(gen_Buffer *buffer, uint32_t value);
bool gen_read_var_u32(gen_Buffer *buffer, uint32_t *out);
bool gen_write_var_u64(gen_Buffer *buffer, uint64_t value);
bool gen_read_var_u64(gen_Buffer *buffer, uint64_t *out);
bool gen_write_var_s32(gen_Buffer *buffer, int32_t value);
bool gen_read_var_s32(gen_Buffer *buffer, int32_t *out);
bool gen_write_var_s64(gen_Buffer *buffer, int64_t value);
bool gen_read_var_s64(gen_Buffer *buffer, int64_t *out);

bool gen_buffer_begin_read_block(gen_Buffer *buffer, uint32_t *block_end) {
    if (!block_end) { return false; }
    uint32_t len = 0;
    if (!gen_read_var_u32(buffer, &len)) { return false; }
    if (buffer->used + len > buffer->size) { return false; }
    *block_end = buffer->used + len;
    return true;
}

bool gen_buffer_end_read_block(gen_Buffer *buffer, uint32_t block_end) {
    if (block_end > buffer->size) { return false; }
    if (buffer->used > block_end) { return false; }
    if (buffer->used < block_end) {
        return gen_buffer_skip_bytes(buffer, (size_t)(block_end - buffer->used));
    }
    return true;
}

uint32_t gen_make_wire_tag(uint32_t field_id, gen_WireType wire) {
    return (field_id << 2) | (uint32_t)wire;
}
bool gen_write_wire_tag(gen_Buffer *buffer, uint32_t field_id, gen_WireType wire) {
    return gen_write_var_u32(buffer, gen_make_wire_tag(field_id, wire));
}
bool gen_read_wire_tag(gen_Buffer *buffer, uint32_t *out_field_id, gen_WireType *out_wire) {
    uint32_t raw = 0;
    if (!gen_read_var_u32(buffer, &raw)) { return false; }
    if (raw == 0) { *out_field_id = 0; *out_wire = gen_WireType_Varint; return true; }
    *out_field_id = raw >> 2;
    *out_wire = (gen_WireType)(raw & 0x3u);
    return true;
}

bool gen_skip_wire_value(gen_Buffer *buffer, gen_WireType wire) {
    switch (wire) {
        case gen_WireType_Varint:
        {
            while (true) {
                uint8_t byte = 0;
                if (!gen_buffer_read_u8(buffer, &byte)) { return false; }
                if ((byte & 0x80u) == 0) { break; }
            }
            return true;
        }
        case gen_WireType_Fixed32:
            return gen_buffer_skip_bytes(buffer, 4);
        case gen_WireType_Fixed64:
            return gen_buffer_skip_bytes(buffer, 8);
        case gen_WireType_LengthDelimited:
        {
            uint32_t len = 0;
            if (!gen_read_var_u32(buffer, &len)) { return false; }
            return gen_buffer_skip_bytes(buffer, len);
        }
        default:
            return false;
    }
}

uint32_t gen_zigzag32(int32_t value) {
    return ((uint32_t)value << 1) ^ (uint32_t)(value >> 31);
}
int32_t gen_unzigzag32(uint32_t value) {
    return (int32_t)((value >> 1) ^ (~(value & 1) + 1));
}
uint64_t gen_zigzag64(int64_t value) {
    return ((uint64_t)value << 1) ^ (uint64_t)(value >> 63);
}
int64_t gen_unzigzag64(uint64_t value) {
    return (int64_t)((value >> 1) ^ (~(value & 1) + 1));
}

bool gen_write_var_u32(gen_Buffer *buffer, uint32_t value) {
    uint8_t bytes[5];
    uint32_t count = 0;
    do {
        uint8_t byte = (uint8_t)(value & 0x7Fu);
        value >>= 7u;
        if (value) { byte |= 0x80u; }
        bytes[count++] = byte;
    } while (value && count < sizeof(bytes));
    return gen_buffer_write_bytes(buffer, bytes, count);
}
bool gen_read_var_u32(gen_Buffer *buffer, uint32_t *out) {
    uint32_t result = 0;
    uint32_t shift = 0;
    for (uint32_t i = 0; i < 5; ++i) {
        uint8_t byte = 0;
        if (!gen_buffer_read_u8(buffer, &byte)) { return false; }
        result |= ((uint32_t)(byte & 0x7Fu) << shift);
        if ((byte & 0x80u) == 0) { *out = result; return true; }
        shift += 7u;
    }
    return false;
}
bool gen_write_var_u64(gen_Buffer *buffer, uint64_t value) {
    uint8_t bytes[10];
    uint32_t count = 0;
    do {
        uint8_t byte = (uint8_t)(value & 0x7Fu);
        value >>= 7u;
        if (value) { byte |= 0x80u; }
        bytes[count++] = byte;
    } while (value && count < sizeof(bytes));
    return gen_buffer_write_bytes(buffer, bytes, count);
}
bool gen_read_var_u64(gen_Buffer *buffer, uint64_t *out) {
    uint64_t result = 0;
    uint32_t shift = 0;
    for (uint32_t i = 0; i < 10; ++i) {
        uint8_t byte = 0;
        if (!gen_buffer_read_u8(buffer, &byte)) { return false; }
        result |= ((uint64_t)(byte & 0x7Fu) << shift);
        if ((byte & 0x80u) == 0) { *out = result; return true; }
        shift += 7u;
    }
    return false;
}
bool gen_write_var_s32(gen_Buffer *buffer, int32_t value) {
    return gen_write_var_u32(buffer, gen_zigzag32(value));
}
bool gen_read_var_s32(gen_Buffer *buffer, int32_t *out) {
    uint32_t tmp = 0;
    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
    *out = gen_unzigzag32(tmp);
    return true;
}
bool gen_write_var_s64(gen_Buffer *buffer, int64_t value) {
    return gen_write_var_u64(buffer, gen_zigzag64(value));
}
bool gen_read_var_s64(gen_Buffer *buffer, int64_t *out) {
    uint64_t tmp = 0;
    if (!gen_read_var_u64(buffer, &tmp)) { return false; }
    *out = gen_unzigzag64(tmp);
    return true;
}
bool gen_buffer_skip(gen_Buffer *buffer, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    buffer->used += (uint32_t)len;
    return true;
}
bool gen_write_field_header(gen_Buffer *buffer, uint32_t field_id, uint32_t type_code) {
    if (!gen_write_var_u32(buffer, field_id)) { return false; }
    if (field_id == 0) { return true; }
    return gen_write_var_u32(buffer, type_code);
}
bool gen_read_field_header(gen_Buffer *buffer, uint32_t *out_field, uint32_t *out_type) {
    if (!gen_read_var_u32(buffer, out_field)) { return false; }
    if (*out_field == 0) { return true; }
    return gen_read_var_u32(buffer, out_type);
}
float gen_denorm_clamp_f32(float value) {
    if (fabsf(value) < FLT_MIN) { return 0.0f; }
    return value;
}
bool gen_write_compact_f32(gen_Buffer *buffer, float value) {
    float normalized = gen_denorm_clamp_f32(value);
    uint8_t flag = normalized == 0.0f ? 0u : 1u;
    if (!gen_buffer_write_u8(buffer, flag)) { return false; }
    if (!flag) { return true; }
#if gen__IS_BIG_ENDIAN
    uint32_t raw; memcpy(&raw, &normalized, 4); raw = gen__bswap32(raw);
    return gen_buffer_write_bytes(buffer, &raw, sizeof(raw));
#else
    return gen_buffer_write_bytes(buffer, &normalized, sizeof(normalized));
#endif
}
bool gen_read_compact_f32(gen_Buffer *buffer, float *out) {
    uint8_t flag = 0;
    if (!gen_buffer_read_u8(buffer, &flag)) { return false; }
    if (!flag) { *out = 0.0f; return true; }
#if gen__IS_BIG_ENDIAN
    uint32_t raw; if (!gen_buffer_read_bytes(buffer, &raw, sizeof(raw))) return false;
    raw = gen__bswap32(raw); memcpy(out, &raw, 4); return true;
#else
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
#endif
}
bool gen_write_compact_f64(gen_Buffer *buffer, double value) {
    double normalized = fabs(value) < DBL_MIN ? 0.0 : value;
    uint8_t flag = normalized == 0.0 ? 0u : 1u;
    if (!gen_buffer_write_u8(buffer, flag)) { return false; }
    if (!flag) { return true; }
#if gen__IS_BIG_ENDIAN
    uint64_t raw; memcpy(&raw, &normalized, 8); raw = gen__bswap64(raw);
    return gen_buffer_write_bytes(buffer, &raw, sizeof(raw));
#else
    return gen_buffer_write_bytes(buffer, &normalized, sizeof(normalized));
#endif
}
bool gen_read_compact_f64(gen_Buffer *buffer, double *out) {
    uint8_t flag = 0;
    if (!gen_buffer_read_u8(buffer, &flag)) { return false; }
    if (!flag) { *out = 0.0; return true; }
#if gen__IS_BIG_ENDIAN
    uint64_t raw; if (!gen_buffer_read_bytes(buffer, &raw, sizeof(raw))) return false;
    raw = gen__bswap64(raw); memcpy(out, &raw, 8); return true;
#else
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
#endif
}
void gen_Achievements_defaults(gen_Achievements *value) {
    memset(value, 0, sizeof(*value));
}

void gen_PlayerState_defaults(gen_PlayerState *value) {
    memset(value, 0, sizeof(*value));
    value->has_yaw = false;
    value->has_posX = false;
    value->has_posY = false;
    value->has_posZ = false;
}

void gen_Player_defaults(gen_Player *value) {
    memset(value, 0, sizeof(*value));
    value->has_id = false;
    value->has_class = false;
    value->class = gen_Class_mage;
    value->has_colors = false;
}

bool gen_ArrayAchievements_read(gen_ArrayAchievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    uint32_t count = 0;
    if (!gen_buffer_read_u32(buffer, &count)) { return false; }
    value->items = NULL;
    value->count = 0;
    if (count == 0) { return true; }
    const uint32_t memory_marker = memory->used;
    gen_Achievements *items = (gen_Achievements *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_Achievements), (sizeof(gen_Achievements) > sizeof(void *)) ? sizeof(gen_Achievements) : sizeof(void *));
    if (!items) { return false; }
    for (uint32_t i = 0; i < count; ++i) {
        gen_Achievements_defaults(&items[i]);
        if (!gen_Achievements_read(&items[i], buffer, memory, schema)) {
            gen_buffer_pop_to(memory, memory_marker);
            return false;
        }
    }
    value->items = items;
    value->count = count;
    return true;
}

bool gen_ArrayAchievements_write(const gen_ArrayAchievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->count)) { return false; }
    for (uint32_t i = 0; i < value->count; ++i) {
        if (!gen_Achievements_write(&value->items[i], buffer, schema)) { return false; }
    }
    return true;
}

bool gen_Achievements_read(gen_Achievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->red)) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->green)) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->blue)) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->alpha)) { return false; }
    return true;
}

bool gen_Achievements_write(const gen_Achievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u8(buffer, value->red)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->green)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->blue)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->alpha)) { return false; }
    return true;
}

bool gen_PlayerState_read(gen_PlayerState *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    uint8_t bitmask[1];
    if (!gen_buffer_read_bytes(buffer, bitmask, sizeof(bitmask))) { return false; }
    value->has_yaw = (bitmask[0] >> 0) & 1u;
    if (value->has_yaw) {
        {
            u32 temp;
            if (!gen_buffer_read_u32(buffer, &temp)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(temp)) & mask;
            value->yaw = (u32)masked;
        }
    }
    value->has_posX = (bitmask[0] >> 1) & 1u;
    if (value->has_posX) {
        {
            i32 temp;
            if (!gen_buffer_read_i32(buffer, &temp)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(temp)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posX = (i32)masked;
        }
    }
    value->has_posY = (bitmask[0] >> 2) & 1u;
    if (value->has_posY) {
        {
            i32 temp;
            if (!gen_buffer_read_i32(buffer, &temp)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(temp)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posY = (i32)masked;
        }
    }
    value->has_posZ = (bitmask[0] >> 3) & 1u;
    if (value->has_posZ) {
        {
            i32 temp;
            if (!gen_buffer_read_i32(buffer, &temp)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(temp)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posZ = (i32)masked;
        }
    }
    return true;
}

bool gen_PlayerState_write(const gen_PlayerState *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    uint8_t bitmask[1];
    memset(bitmask, 0, sizeof(bitmask));
    if (value->has_yaw) { bitmask[0] |= (1u << 0); }
    if (value->has_posX) { bitmask[0] |= (1u << 1); }
    if (value->has_posY) { bitmask[0] |= (1u << 2); }
    if (value->has_posZ) { bitmask[0] |= (1u << 3); }
    if (!gen_buffer_write_bytes(buffer, bitmask, sizeof(bitmask))) { return false; }
    if (value->has_yaw) {
        {
            u32 temp;
            const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->yaw)) & mask;
            temp = (u32)masked;
            if (!gen_buffer_write_u32(buffer, temp)) { return false; }
        }
    }
    if (value->has_posX) {
        {
            i32 temp;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posX)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            temp = (i32)masked;
            if (!gen_buffer_write_i32(buffer, temp)) { return false; }
        }
    }
    if (value->has_posY) {
        {
            i32 temp;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posY)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            temp = (i32)masked;
            if (!gen_buffer_write_i32(buffer, temp)) { return false; }
        }
    }
    if (value->has_posZ) {
        {
            i32 temp;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posZ)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            temp = (i32)masked;
            if (!gen_buffer_write_i32(buffer, temp)) { return false; }
        }
    }
    return true;
}

bool gen_Player_read(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    if (!gen_buffer_read_u32(buffer, &value->id)) { return false; }
    {
        u32 raw = 0;
        if (!gen_buffer_read_u32(buffer, &raw)) { return false; }
        value->class = (gen_Class)raw;
    }
    if (!gen_ArrayAchievements_read(&value->colors, buffer, memory, schema)) { return false; }
    return true;
}

bool gen_Player_write(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->id)) { return false; }
    if (!gen_buffer_write_u32(buffer, (u32)value->class)) { return false; }
    if (!gen_ArrayAchievements_write(&value->colors, buffer, schema)) { return false; }
    return true;
}

static const gen_ParameterInfo gen_Achievements_parameters[] = {
    { "red", gen_achievementsParameters_red, gen_type_u8, offsetof(gen_Achievements, red) },
    { "green", gen_achievementsParameters_green, gen_type_u8, offsetof(gen_Achievements, green) },
    { "blue", gen_achievementsParameters_blue, gen_type_u8, offsetof(gen_Achievements, blue) },
    { "alpha", gen_achievementsParameters_alpha, gen_type_u8, offsetof(gen_Achievements, alpha) },
};

static const gen_ParameterInfo gen_PlayerState_parameters[] = {
    { "yaw", gen_playerStateParameters_yaw, gen_type_u32, UINT32_MAX },
    { "posX", gen_playerStateParameters_posX, gen_type_i32, UINT32_MAX },
    { "posY", gen_playerStateParameters_posY, gen_type_i32, UINT32_MAX },
    { "posZ", gen_playerStateParameters_posZ, gen_type_i32, UINT32_MAX },
};

static const gen_ParameterInfo gen_Player_parameters[] = {
    { "id", gen_playerParameters_id, gen_type_u32, offsetof(gen_Player, id) },
    { "class", gen_playerParameters_class, gen_type_Class, offsetof(gen_Player, class) },
    { "colors", gen_playerParameters_colors, gen_type_ArrayAchievements, offsetof(gen_Player, colors) },
};

static const gen_TypeDescription gen_type_descriptions[] = {
    { "Achievements", gen_type_Achievements, sizeof(gen_Achievements), sizeof(gen_Achievements), gen_Achievements_parameters, 4 },
    { "PlayerState", gen_type_PlayerState, sizeof(gen_PlayerState), sizeof(gen_PlayerState), gen_PlayerState_parameters, 4 },
    { "Player", gen_type_Player, sizeof(gen_Player), sizeof(gen_Player), gen_Player_parameters, 3 },
};

const gen_TypeDescription *gen_get_type_description(gen_type type_id) {
    for (size_t i = 0; i < sizeof(gen_type_descriptions)/sizeof(gen_type_descriptions[0]); ++i) {
        if (gen_type_descriptions[i].type_id == type_id) { return &gen_type_descriptions[i]; }
    }
    return NULL;
}
bool gen_Achievements_encode_compact(const gen_Achievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u8(buffer, value->red)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->green)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->blue)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->alpha)) { return false; }
    return true;
}

bool gen_Achievements_decode_compact(gen_Achievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (schema) {
        const gen_SchemaType *type = NULL;
        for (uint32_t i = 0; i < schema->type_count; ++i) {
            if (strcmp(schema->types[i].name, "Achievements") == 0) {
                type = &schema->types[i];
                break;
            }
        }
        if (!type) return false;
        uint32_t optional_count = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            if (type->fields[i].is_optional) optional_count++;
        }
        uint8_t mask_buf[128];
        uint8_t *bitmask = NULL;
        if (optional_count > 0) {
            uint32_t bytes = (optional_count + 7) / 8;
            if (bytes > sizeof(mask_buf)) return false;
            if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
            bitmask = mask_buf;
        }
        uint32_t opt_idx = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            bool present = true;
            if (type->fields[i].is_optional) {
                present = (bitmask[opt_idx / 8] >> (opt_idx % 8)) & 1;
                opt_idx++;
            }
            printf("Field %s (mapping %d) present: %d\n", type->fields[i].name, type->fields[i].mapping, present);
            if (!present) continue;
            switch (type->fields[i].mapping) {
                case gen_achievementsParameters_red: {
                    if (!gen_buffer_read_u8(buffer, &value->red)) { return false; }
                    break;
                }
                case gen_achievementsParameters_green: {
                    if (!gen_buffer_read_u8(buffer, &value->green)) { return false; }
                    break;
                }
                case gen_achievementsParameters_blue: {
                    if (!gen_buffer_read_u8(buffer, &value->blue)) { return false; }
                    break;
                }
                case gen_achievementsParameters_alpha: {
                    if (!gen_buffer_read_u8(buffer, &value->alpha)) { return false; }
                    break;
                }
                default:
                    if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
                    break;
            }
        }
        return true;
    }

    if (!gen_buffer_read_u8(buffer, &value->red)) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->green)) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->blue)) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->alpha)) { return false; }
    return true;
}

bool gen_Achievements_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_WireType wire = gen_WireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

bool gen_PlayerState_encode_compact(const gen_PlayerState *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    uint8_t bitmask[1];
    memset(bitmask, 0, sizeof(bitmask));
    if (value->has_yaw) { bitmask[0] |= (1u << 0); }
    if (value->has_posX) { bitmask[0] |= (1u << 1); }
    if (value->has_posY) { bitmask[0] |= (1u << 2); }
    if (value->has_posZ) { bitmask[0] |= (1u << 3); }
    if (!gen_buffer_write_bytes(buffer, bitmask, sizeof(bitmask))) { return false; }
    if (value->has_yaw) {
        {
            u32 bw_value;
            const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->yaw)) & mask;
            bw_value = (u32)masked;
            if (!gen_write_var_u32(buffer, (uint32_t)bw_value)) { return false; }
        }
    }
    if (value->has_posX) {
        {
            i32 bw_value;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posX)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            bw_value = (i32)masked;
            if (!gen_write_var_s32(buffer, (int32_t)bw_value)) { return false; }
        }
    }
    if (value->has_posY) {
        {
            i32 bw_value;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posY)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            bw_value = (i32)masked;
            if (!gen_write_var_s32(buffer, (int32_t)bw_value)) { return false; }
        }
    }
    if (value->has_posZ) {
        {
            i32 bw_value;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posZ)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            bw_value = (i32)masked;
            if (!gen_write_var_s32(buffer, (int32_t)bw_value)) { return false; }
        }
    }
    return true;
}

bool gen_PlayerState_decode_compact(gen_PlayerState *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (schema) {
        const gen_SchemaType *type = NULL;
        for (uint32_t i = 0; i < schema->type_count; ++i) {
            if (strcmp(schema->types[i].name, "PlayerState") == 0) {
                type = &schema->types[i];
                break;
            }
        }
        if (!type) return false;
        uint32_t optional_count = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            if (type->fields[i].is_optional) optional_count++;
        }
        uint8_t mask_buf[128];
        uint8_t *bitmask = NULL;
        if (optional_count > 0) {
            uint32_t bytes = (optional_count + 7) / 8;
            if (bytes > sizeof(mask_buf)) return false;
            if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
            bitmask = mask_buf;
        }
        uint32_t opt_idx = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            bool present = true;
            if (type->fields[i].is_optional) {
                present = (bitmask[opt_idx / 8] >> (opt_idx % 8)) & 1;
                opt_idx++;
            }
            printf("Field %s (mapping %d) present: %d\n", type->fields[i].name, type->fields[i].mapping, present);
            if (!present) continue;
            switch (type->fields[i].mapping) {
                case gen_playerStateParameters_yaw: {
                    value->has_yaw = true;
                    {
                        u32 bw_value;
                        {
                            uint32_t tmp = 0;
                            if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                            bw_value = (uint32_t)tmp;
                        }
                        const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
                        uint64_t masked = ((uint64_t)(bw_value)) & mask;
                        value->yaw = (u32)masked;
                    }
                    break;
                }
                case gen_playerStateParameters_posX: {
                    value->has_posX = true;
                    {
                        i32 bw_value;
                        {
                            int32_t tmp = 0;
                            if (!gen_read_var_s32(buffer, &tmp)) { return false; }
                            bw_value = (int32_t)tmp;
                        }
                        const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
                        uint64_t masked = ((uint64_t)(bw_value)) & mask;
                        const uint64_t sign_bit = UINT64_C(1) << 19;
                        if (masked & sign_bit) { masked |= ~mask; }
                        value->posX = (i32)masked;
                    }
                    break;
                }
                case gen_playerStateParameters_posY: {
                    value->has_posY = true;
                    {
                        i32 bw_value;
                        {
                            int32_t tmp = 0;
                            if (!gen_read_var_s32(buffer, &tmp)) { return false; }
                            bw_value = (int32_t)tmp;
                        }
                        const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
                        uint64_t masked = ((uint64_t)(bw_value)) & mask;
                        const uint64_t sign_bit = UINT64_C(1) << 19;
                        if (masked & sign_bit) { masked |= ~mask; }
                        value->posY = (i32)masked;
                    }
                    break;
                }
                case gen_playerStateParameters_posZ: {
                    value->has_posZ = true;
                    {
                        i32 bw_value;
                        {
                            int32_t tmp = 0;
                            if (!gen_read_var_s32(buffer, &tmp)) { return false; }
                            bw_value = (int32_t)tmp;
                        }
                        const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
                        uint64_t masked = ((uint64_t)(bw_value)) & mask;
                        const uint64_t sign_bit = UINT64_C(1) << 19;
                        if (masked & sign_bit) { masked |= ~mask; }
                        value->posZ = (i32)masked;
                    }
                    break;
                }
                default:
                    if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
                    break;
            }
        }
        return true;
    }

    uint8_t bitmask[1];
    if (!gen_buffer_read_bytes(buffer, bitmask, sizeof(bitmask))) { return false; }
    value->has_yaw = (bitmask[0] >> 0) & 1u;
    if (value->has_yaw) {
        {
            u32 bw_value;
            {
                uint32_t tmp = 0;
                if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                bw_value = (uint32_t)tmp;
            }
            const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(bw_value)) & mask;
            value->yaw = (u32)masked;
        }
    }
    value->has_posX = (bitmask[0] >> 1) & 1u;
    if (value->has_posX) {
        {
            i32 bw_value;
            {
                int32_t tmp = 0;
                if (!gen_read_var_s32(buffer, &tmp)) { return false; }
                bw_value = (int32_t)tmp;
            }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(bw_value)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posX = (i32)masked;
        }
    }
    value->has_posY = (bitmask[0] >> 2) & 1u;
    if (value->has_posY) {
        {
            i32 bw_value;
            {
                int32_t tmp = 0;
                if (!gen_read_var_s32(buffer, &tmp)) { return false; }
                bw_value = (int32_t)tmp;
            }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(bw_value)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posY = (i32)masked;
        }
    }
    value->has_posZ = (bitmask[0] >> 3) & 1u;
    if (value->has_posZ) {
        {
            i32 bw_value;
            {
                int32_t tmp = 0;
                if (!gen_read_var_s32(buffer, &tmp)) { return false; }
                bw_value = (int32_t)tmp;
            }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(bw_value)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posZ = (i32)masked;
        }
    }
    return true;
}

bool gen_PlayerState_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_WireType wire = gen_WireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

bool gen_Player_encode_compact(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (true) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_id, gen_WireType_Varint)) { return false; }
        if (!gen_write_var_u32(buffer, (uint32_t)value->id)) { return false; }
    }
    if (true) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_class, gen_WireType_Varint)) { return false; }
        if (!gen_write_var_u32(buffer, (uint32_t)value->class)) { return false; }
    }
    if (value->colors.count > 0) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_colors, gen_WireType_LengthDelimited)) { return false; }
        uint32_t block_marker = 0;
        if (!gen_buffer_begin_block(buffer, &block_marker)) { return false; }
        if (!gen_write_var_u32(buffer, value->colors.count)) { return false; }
        for (uint32_t i = 0; i < value->colors.count; ++i) {
            if (!gen_Achievements_encode_compact(&value->colors.items[i], buffer, schema)) { return false; }
        }
        if (!gen_buffer_end_block(buffer, block_marker)) { return false; }
    }
    if (!gen_write_var_u32(buffer, 0)) { return false; }
    return true;
}

bool gen_Player_decode_compact(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    while (true) {
        uint32_t field_id = 0;
        gen_WireType wire = gen_WireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        switch (field_id) {
            case gen_playerParameters_id: {
                {
                    uint32_t tmp = 0;
                    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                    value->id = (uint32_t)tmp;
                }
                break;
            }
            case gen_playerParameters_class: {
                {
                    uint32_t tmp = 0;
                    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                    value->class = (uint32_t)tmp;
                }
                break;
            }
            case gen_playerParameters_colors: {
                if (wire != gen_WireType_LengthDelimited) { return false; }
                uint32_t block_end = 0;
                if (!gen_buffer_begin_read_block(buffer, &block_end)) { return false; }
                uint32_t count = 0;
                if (!gen_read_var_u32(buffer, &count)) { return false; }
                value->colors.items = NULL;
                value->colors.count = 0;
                if (count) {
                    const uint32_t memory_marker = memory->used;
                    gen_Achievements *items = (gen_Achievements *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_Achievements), (sizeof(gen_Achievements) > sizeof(void *)) ? sizeof(gen_Achievements) : sizeof(void *));
                    if (!items) { return false; }
                    for (uint32_t i = 0; i < count; ++i) {
                        gen_Achievements_defaults(&items[i]);
                        if (!gen_Achievements_decode_compact(&items[i], buffer, memory, schema)) {
                            gen_buffer_pop_to(memory, memory_marker);
                            return false;
                        }
                    }
                    value->colors.items = items;
                    value->colors.count = count;
                }
                if (!gen_buffer_end_read_block(buffer, block_end)) { return false; }
                break;
            }
            default:
                if (!gen_skip_wire_value(buffer, wire)) { return false; }
                break;
        }
    }
    return true;
}

bool gen_Player_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_WireType wire = gen_WireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

#define gen_BINARY_MAGIC "BKIW"
#define gen_BINARY_VERSION 1

const uint8_t gen_schema_blob[] = {

    0x42, 0x4b, 0x49, 0x57, 0x01, 0x04, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x00, 0x00, 0x0b, 0x00, 0x41, 
    0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x00, 0x01, 0x0c, 0x04, 0x72, 
    0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x00, 0x01, 0x00, 0x00, 0x62, 
    0x6c, 0x75, 0x65, 0x00, 0x02, 0x00, 0x00, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x00, 0x03, 0x00, 0x00, 
    0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x01, 0x0d, 0x04, 0x79, 
    0x61, 0x77, 0x00, 0x00, 0x02, 0x02, 0x70, 0x6f, 0x73, 0x58, 0x00, 0x01, 0x06, 0x02, 0x70, 0x6f, 
    0x73, 0x59, 0x00, 0x02, 0x06, 0x02, 0x70, 0x6f, 0x73, 0x5a, 0x00, 0x03, 0x06, 0x02, 0x50, 0x6c, 
    0x61, 0x79, 0x65, 0x72, 0x00, 0x02, 0x0e, 0x03, 0x69, 0x64, 0x00, 0x01, 0x02, 0x00, 0x63, 0x6c, 
    0x61, 0x73, 0x73, 0x00, 0x02, 0x0b, 0x00, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 0x00, 0x03, 0x0c, 
    0x01, 
};

static const char *gen_read_strz(const uint8_t **cursor, const uint8_t *end) {
    const char *str = (const char *)*cursor;
    while (*cursor < end && **cursor != 0) { (*cursor)++; }
    if (*cursor < end) { (*cursor)++; return str; }
    return "";
}

static uint64_t gen_read_varuint(const uint8_t **cursor, const uint8_t *end) {
    uint64_t result = 0;
    uint32_t shift = 0;
    while (*cursor < end) {
        uint8_t byte = *(*cursor)++;
        result |= ((uint64_t)(byte & 0x7F) << shift);
        if ((byte & 0x80) == 0) { break; }
        shift += 7;
    }
    return result;
}

const gen_SchemaInfo *gen_parse_schema(const uint8_t *data, size_t size, gen_Buffer *allocator) {
    if (!data || !allocator) return NULL;
    const uint8_t *cursor = data;
    const uint8_t *end = data + size;
    if (size < 5 || memcmp(cursor, gen_BINARY_MAGIC, 4) != 0) return NULL;
    cursor += 4;
    uint8_t version = *cursor++;
    if (version != gen_BINARY_VERSION) return NULL;
    
    uint64_t count = gen_read_varuint(&cursor, end);
    gen_SchemaInfo *info = (gen_SchemaInfo *)gen_buffer_push_aligned(allocator, sizeof(gen_SchemaInfo), sizeof(void*));
    if (!info) return NULL;
    info->version = version;
    info->type_count = (uint32_t)count;
    info->types = (gen_SchemaType *)gen_buffer_push_aligned(allocator, sizeof(gen_SchemaType) * count, sizeof(void*));
    if (!info->types) return NULL;
    
    for (uint32_t i = 0; i < count; ++i) {
        gen_SchemaType *type = &info->types[i];
        type->name = gen_read_strz(&cursor, end);
        type->kind = *cursor++;
        type->type_id = (uint32_t)gen_read_varuint(&cursor, end);
        uint64_t fcount = gen_read_varuint(&cursor, end);
        type->field_count = (uint32_t)fcount;
        if (fcount > 0) {
            type->fields = (gen_SchemaField *)gen_buffer_push_aligned(allocator, sizeof(gen_SchemaField) * fcount, sizeof(void*));
            if (!type->fields) return NULL;
            for (uint32_t j = 0; j < fcount; ++j) {
                type->fields[j].name = gen_read_strz(&cursor, end);
                type->fields[j].id = (uint32_t)gen_read_varuint(&cursor, end);
                type->fields[j].type_id = (uint32_t)gen_read_varuint(&cursor, end);
                uint8_t flags = *cursor++;
                type->fields[j].is_array = (flags & 1) != 0;
                type->fields[j].is_optional = (flags & 2) != 0;
                type->fields[j].is_deprecated = (flags & 4) != 0;
                type->fields[j].mapping = -1;
            }
        } else {
            type->fields = NULL;
        }
    }
    
    // Resolve schema against local types
    for (uint32_t i = 0; i < info->type_count; ++i) {
        gen_SchemaType *type = &info->types[i];
        const gen_TypeDescription *desc = NULL;
        for (size_t j = 0; j < sizeof(gen_type_descriptions)/sizeof(gen_type_descriptions[0]); ++j) {
            if (strcmp(gen_type_descriptions[j].name, type->name) == 0) {
                desc = &gen_type_descriptions[j];
                break;
            }
        }
        if (!desc) continue;
        
        for (uint32_t j = 0; j < type->field_count; ++j) {
            gen_SchemaField *field = &type->fields[j];
            for (uint32_t k = 0; k < desc->parameter_count; ++k) {
                if (strcmp(desc->parameters[k].name, field->name) == 0) {
                    field->mapping = (int32_t)desc->parameters[k].parameter_id;
                    printf("Resolved field %s to mapping %d\n", field->name, field->mapping);
                    break;
                }
            }
        }
    }
    return info;
}

const uint8_t *gen_get_schema_blob(size_t *out_size) {
    if (out_size) { *out_size = sizeof(gen_schema_blob); }
    return gen_schema_blob;
}

const gen_SchemaInfo *gen_get_embedded_schema(gen_Buffer *allocator) {
    return gen_parse_schema(gen_schema_blob, sizeof(gen_schema_blob), allocator);
}

bool gen_skip_generic(gen_Buffer *buffer, uint32_t type_id, bool is_array, const gen_SchemaInfo *schema) {
    if (is_array) {
        uint32_t count = 0;
        if (!gen_read_var_u32(buffer, &count)) return false;
        for (uint32_t i = 0; i < count; ++i) {
            if (!gen_skip_generic(buffer, type_id, false, schema)) return false;
        }
        return true;
    }
    // Builtins
    if (type_id < 11) {
        switch (type_id) {
            case 0: // u8
            case 4: // i8
            case 10: // bool
                return gen_buffer_skip_bytes(buffer, 1);
            case 1: // u16
            case 2: // u32
            case 5: // i16
            case 6: // i32
            {
                uint32_t tmp; return gen_read_var_u32(buffer, &tmp);
            }
            case 3: // u64
            case 7: // i64
            {
                uint64_t tmp; return gen_read_var_u64(buffer, &tmp);
            }
            case 8: // f32
            {
                float tmp; return gen_read_compact_f32(buffer, &tmp);
            }
            case 9: // f64
            {
                double tmp; return gen_read_compact_f64(buffer, &tmp);
            }
        }
        return false;
    }
    // Look up in schema
    if (!schema) return false;
    const gen_SchemaType *type = NULL;
    for (uint32_t i = 0; i < schema->type_count; ++i) {
        if (schema->types[i].type_id == type_id) {
            type = &schema->types[i];
            break;
        }
    }
    if (!type) return false;
    
    if (type->kind == 0) { // ENUM
        uint32_t tmp; return gen_read_var_u32(buffer, &tmp);
    }
    
    // STRUCT or MESSAGE
    if (type->kind == 2) { // MESSAGE
        // Messages are length delimited in some contexts, but here we assume compact stream
        // Wait, messages in compact encoding are just structs with ID field.
        // But wait, `append_message_codec` uses `write_wire_tag` and blocks for optional fields.
        // If we are skipping a message in a compact stream, it might be encoded as a struct (recursively) OR as a block.
        // In `append_struct_codec`, nested structs are just `_encode_compact`.
        // In `append_message_codec`, nested structs are `_encode_compact`.
        // So they are just fields.
        // BUT, `append_message_codec` writes a 0 tag at the end.
        // So we need to skip until tag 0.
        while (true) {
            uint32_t field_id = 0;
            gen_WireType wire = gen_WireType_Varint;
            if (!gen_read_wire_tag(buffer, &field_id, &wire)) return false;
            if (field_id == 0) break;
            if (!gen_skip_wire_value(buffer, wire)) return false;
        }
        return true;
    }
    
    // STRUCT
    // Read bitmask
    uint32_t optional_count = 0;
    for (uint32_t i = 0; i < type->field_count; ++i) {
        if (type->fields[i].is_optional) optional_count++;
    }
    uint8_t *bitmask = NULL;
    if (optional_count > 0) {
        uint32_t bytes = (optional_count + 7) / 8;
        // We need to read bytes but not store them permanently, just on stack or skip
        // But we need them to know which optionals to skip.
        // We can allocate on stack if small, or use allocator? No allocator passed here.
        // Use a small fixed buffer or alloca? standard C99 doesn't have alloca.
        // Let's use a fixed max size (e.g. 64 bytes = 512 optionals) or just read byte by byte?
        // We can't read byte by byte easily because we need random access or sequential access.
        // Sequential access is fine. We iterate fields.
        // But the bitmask is at the START.
        // So we must read it all.
        // Let's assume a max of 128 bytes (1024 optionals). If more, fail.
        if (bytes > 128) return false;
        uint8_t mask_buf[128];
        if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
        bitmask = mask_buf;
    }
    
    uint32_t opt_idx = 0;
    for (uint32_t i = 0; i < type->field_count; ++i) {
        bool present = true;
        if (type->fields[i].is_optional) {
            present = (bitmask[opt_idx / 8] >> (opt_idx        )) & 1;
            opt_idx++;
        }
        if (present) {
            if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
        }
    }
    return true;
}

#endif /* GEN__IMPLEMENTATION */
