// Generated by schema_gen from ref.hischema
#ifndef GEN__H_INCLUDE
#define GEN__H_INCLUDE

// To create the implementation, define GEN__IMPLEMENTATION before including this file in one translation unit.

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef GEN__API
#  ifdef GEN__STATIC
#    define GEN__API static
#  else
#    define GEN__API extern
#  endif
#endif

#ifndef GEN_DEPRECATED
#  if defined(__GNUC__) || defined(__clang__)
#    define GEN_DEPRECATED(msg) __attribute__((deprecated(msg)))
#  else
#    define GEN_DEPRECATED(msg)
#  endif
#endif

#if defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#  define gen__IS_BIG_ENDIAN 1
#elif defined(__BIG_ENDIAN__)
#  define gen__IS_BIG_ENDIAN 1
#else
#  define gen__IS_BIG_ENDIAN 0
#endif

#if gen__IS_BIG_ENDIAN
#  ifdef _MSC_VER
#    include <stdlib.h>
#    define gen__bswap16(x) _byteswap_ushort(x)
#    define gen__bswap32(x) _byteswap_ulong(x)
#    define gen__bswap64(x) _byteswap_uint64(x)
#  elif defined(__GNUC__) || defined(__clang__)
#    define gen__bswap16(x) __builtin_bswap16(x)
#    define gen__bswap32(x) __builtin_bswap32(x)
#    define gen__bswap64(x) __builtin_bswap64(x)
#  else
     static inline uint16_t gen__bswap16(uint16_t x) { return (x >> 8) | (x << 8); }
     static inline uint32_t gen__bswap32(uint32_t x) { return ((x >> 24) & 0xff) | ((x >> 8) & 0xff00) | ((x << 8) & 0xff0000) | ((x << 24) & 0xff000000); }
     static inline uint64_t gen__bswap64(uint64_t x) { return ((x >> 56) & 0xff) | ((x >> 40) & 0xff00) | ((x >> 24) & 0xff0000) | ((x >> 8) & 0xff000000) | ((x << 8) & 0xff00000000) | ((x << 24) & 0xff0000000000) | ((x << 40) & 0xff000000000000) | ((x << 56) & 0xff00000000000000); }
#  endif
#endif

typedef struct gen_Buffer {
    void *ptr;
    uint32_t size;
    uint32_t used;
} gen_Buffer;

typedef struct gen_SchemaInfo gen_SchemaInfo;

typedef struct gen_str8 {
    uint8_t *content;
    uint64_t size;
} gen_str8;

GEN__API void gen_buffer_init(gen_Buffer *buffer, void *ptr, uint32_t size);
typedef enum gen_wireType {
    gen_wireType_Varint = 0,
    gen_wireType_Fixed32 = 1,
    gen_wireType_Fixed64 = 2,
    gen_wireType_LengthDelimited = 3,
} gen_wireType;

typedef struct gen_Achievements gen_Achievements;
typedef struct gen_PlayerState gen_PlayerState;
typedef struct gen_StringAchievementsPair gen_StringAchievementsPair;
typedef struct gen_Player gen_Player;

typedef struct gen_AchievementsArray gen_AchievementsArray;
typedef struct gen_StringAchievementsPairArray gen_StringAchievementsPairArray;

typedef enum gen_Class {
    gen_Class_fighter = 0,
    gen_Class_mage = 1,
    gen_Class_summoner = 2,
} gen_Class;

typedef uint8_t gen_PlayerFlags;
enum {
    gen_PlayerFlags_isBanned = 1,
    gen_PlayerFlags_emailConfirmed = 2,
    gen_PlayerFlags_isAdmin = 4,
};

struct gen_AchievementsArray {
    gen_Achievements *items;
    uint32_t count;
};

struct gen_StringAchievementsPairArray {
    gen_StringAchievementsPair *items;
    uint32_t count;
};

struct gen_Achievements {
    u32 questsCompleted;
    u32 bossesDefeated;
    uint16_t secretsFound;
    uint8_t rank;
    uint8_t prestigeLevel;
};

struct gen_PlayerState {
    bool yawExist;
    u32 yaw : 10;
    bool posXExist;
    i32 posX : 20;
    bool posYExist;
    i32 posY : 20;
    bool posZExist;
    i32 posZ : 20;
};

struct gen_StringAchievementsPair {
    gen_str8 key;
    gen_Achievements value;
};

struct gen_Player {
    bool idExist;
    u32 id;
    bool flagsExist;
    gen_PlayerFlags flags;
    bool classExist;
    gen_Class class;
    bool achievementsExist;
    gen_AchievementsArray achievements;
    bool extraSeq3Exist;
    u32 extraSeq3;
    bool mapExist;
    gen_StringAchievementsPairArray map;
    bool extraSeq2Exist;
    u32 extraSeq2 GEN_DEPRECATED("deprecated");
};

GEN__API bool gen_AchievementsArray_read(gen_AchievementsArray *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_AchievementsArray_write(const gen_AchievementsArray *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementsPairArray_read(gen_StringAchievementsPairArray *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementsPairArray_write(const gen_StringAchievementsPairArray *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievements_read(gen_Achievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievements_write(const gen_Achievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_PlayerState_read(gen_PlayerState *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_PlayerState_write(const gen_PlayerState *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementsPair_read(gen_StringAchievementsPair *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementsPair_write(const gen_StringAchievementsPair *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_read(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_write(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);

typedef enum gen_type {
    gen_type_u8,
    gen_type_u16,
    gen_type_u32,
    gen_type_u64,
    gen_type_i8,
    gen_type_i16,
    gen_type_i32,
    gen_type_i64,
    gen_type_f32,
    gen_type_f64,
    gen_type_bool,
    gen_type_string,
    gen_type_Class,
    gen_type_PlayerFlags,
    gen_type_Achievements,
    gen_type_PlayerState,
    gen_type_StringAchievementsPair,
    gen_type_Player,
    gen_type_ArrayAchievements,
    gen_type_ArrayStringAchievementsPair,
} gen_type;

typedef struct gen_ParameterInfo {
    const char *name;
    uint32_t parameter_id;
    gen_type type_id;
    uint32_t offset;
} gen_ParameterInfo;

typedef struct gen_TypeDescription {
    const char *name;
    gen_type type_id;
    size_t struct_size;
    size_t no_padding_struct_size;
    const gen_ParameterInfo *parameters;
    uint32_t parameter_count;
} gen_TypeDescription;

typedef enum gen_achievementsParameters {
    gen_achievementsParameters_questsCompleted = 0,
    gen_achievementsParameters_bossesDefeated = 1,
    gen_achievementsParameters_secretsFound = 2,
    gen_achievementsParameters_rank = 3,
    gen_achievementsParameters_prestigeLevel = 4,
} gen_achievementsParameters;

typedef enum gen_playerStateParameters {
    gen_playerStateParameters_yaw = 0,
    gen_playerStateParameters_posX = 1,
    gen_playerStateParameters_posY = 2,
    gen_playerStateParameters_posZ = 3,
} gen_playerStateParameters;

typedef enum gen_stringAchievementsPairParameters {
    gen_stringAchievementsPairParameters_key = 0,
    gen_stringAchievementsPairParameters_value = 1,
} gen_stringAchievementsPairParameters;

typedef enum gen_playerParameters {
    gen_playerParameters_id = 1,
    gen_playerParameters_flags = 2,
    gen_playerParameters_class = 3,
    gen_playerParameters_achievements = 4,
    gen_playerParameters_extraSeq3 = 7,
    gen_playerParameters_map = 8,
    gen_playerParameters_extraSeq2 = 6,
} gen_playerParameters;

GEN__API const gen_TypeDescription *gen_get_type_description(gen_type type_id);
GEN__API bool gen_Achievements_encode_compact(const gen_Achievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievements_decode_compact(gen_Achievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievements_skip_compact(gen_Buffer *buffer);

GEN__API bool gen_PlayerState_encode_compact(const gen_PlayerState *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_PlayerState_decode_compact(gen_PlayerState *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_PlayerState_skip_compact(gen_Buffer *buffer);

GEN__API bool gen_StringAchievementsPair_encode_compact(const gen_StringAchievementsPair *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementsPair_decode_compact(gen_StringAchievementsPair *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementsPair_skip_compact(gen_Buffer *buffer);

GEN__API bool gen_Player_encode_compact(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_decode_compact(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_skip_compact(gen_Buffer *buffer);

typedef struct gen_SchemaField {
    const char *name;
    uint32_t id;
    uint32_t type_id;
    uint32_t bit_width;
    bool is_array;
    bool is_optional;
    bool is_deprecated;
    bool is_removed;
    int32_t mapping;
} gen_SchemaField;

typedef struct gen_SchemaType {
    const char *name;
    uint8_t kind; // 0=ENUM, 1=STRUCT, 2=MESSAGE
    uint32_t type_id;
    gen_SchemaField *fields;
    uint32_t field_count;
} gen_SchemaType;

struct gen_SchemaInfo {
    uint8_t version;
    gen_SchemaType *types;
    uint32_t type_count;
};

GEN__API const gen_SchemaInfo *gen_parse_schema(const uint8_t *data, size_t size, gen_Buffer *allocator);
GEN__API const uint8_t *gen_get_schema_blob(size_t *out_size);
GEN__API const gen_SchemaInfo *gen_get_embedded_schema(gen_Buffer *allocator);
GEN__API bool gen_skip_generic(gen_Buffer *buffer, uint32_t type_id, bool is_array, const gen_SchemaInfo *schema);
#ifdef __cplusplus
}
#endif

#endif /* GEN__H_INCLUDE */

#ifdef GEN__IMPLEMENTATION

void gen_buffer_init(gen_Buffer *buffer, void *ptr, uint32_t size) {
    buffer->ptr = ptr;
    buffer->size = size;
    buffer->used = 0;
}

bool gen_buffer_read_bytes(gen_Buffer *buffer, void *dst, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    const uint8_t *base = (const uint8_t *)buffer->ptr;
    memcpy(dst, base + buffer->used, len);
    buffer->used += (uint32_t)len;
    return true;
}

bool gen_buffer_write_bytes(gen_Buffer *buffer, const void *src, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    uint8_t *base = (uint8_t *)buffer->ptr;
    memcpy(base + buffer->used, src, len);
    buffer->used += (uint32_t)len;
    return true;
}

size_t gen_buffer_align_forward(size_t value, size_t alignment) {
    if (alignment < sizeof(void *)) { alignment = sizeof(void *); }
    size_t remainder = value % alignment;
    if (remainder) { value += alignment - remainder; }
    return value;
}

void *gen_buffer_push_aligned(gen_Buffer *buffer, size_t len, size_t alignment) {
    if (!buffer) { return NULL; }
    size_t offset = gen_buffer_align_forward((size_t)buffer->used, alignment);
    size_t end = offset + len;
    if (end > (size_t)buffer->size) { return NULL; }
    uint8_t *base = (uint8_t *)buffer->ptr;
    void *ptr = base + offset;
    buffer->used = (uint32_t)end;
    return ptr;
}

bool gen_buffer_pop_to(gen_Buffer *buffer, uint32_t marker) {
    if (!buffer) { return false; }
    if (marker > buffer->used) { return false; }
    buffer->used = marker;
    return true;
}

bool gen_buffer_read_u8(gen_Buffer *buffer, uint8_t *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_u8(gen_Buffer *buffer, const uint8_t value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_u16(gen_Buffer *buffer, uint16_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (uint16_t)gen__bswap16((uint16_t)*out);
#endif
    return true;
}
bool gen_buffer_write_u16(gen_Buffer *buffer, const uint16_t value) {
#if gen__IS_BIG_ENDIAN
    uint16_t swapped = (uint16_t)gen__bswap16((uint16_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_u32(gen_Buffer *buffer, u32 *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_u32(gen_Buffer *buffer, const u32 value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_u64(gen_Buffer *buffer, uint64_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (uint64_t)gen__bswap64((uint64_t)*out);
#endif
    return true;
}
bool gen_buffer_write_u64(gen_Buffer *buffer, const uint64_t value) {
#if gen__IS_BIG_ENDIAN
    uint64_t swapped = (uint64_t)gen__bswap64((uint64_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_i8(gen_Buffer *buffer, int8_t *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_i8(gen_Buffer *buffer, const int8_t value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_i16(gen_Buffer *buffer, int16_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (int16_t)gen__bswap16((uint16_t)*out);
#endif
    return true;
}
bool gen_buffer_write_i16(gen_Buffer *buffer, const int16_t value) {
#if gen__IS_BIG_ENDIAN
    int16_t swapped = (int16_t)gen__bswap16((uint16_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_i32(gen_Buffer *buffer, i32 *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_i32(gen_Buffer *buffer, const i32 value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_i64(gen_Buffer *buffer, int64_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (int64_t)gen__bswap64((uint64_t)*out);
#endif
    return true;
}
bool gen_buffer_write_i64(gen_Buffer *buffer, const int64_t value) {
#if gen__IS_BIG_ENDIAN
    int64_t swapped = (int64_t)gen__bswap64((uint64_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_f32(gen_Buffer *buffer, f32 *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_f32(gen_Buffer *buffer, const f32 value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_f64(gen_Buffer *buffer, double *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_f64(gen_Buffer *buffer, const double value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_bool(gen_Buffer *buffer, bool *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_bool(gen_Buffer *buffer, const bool value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_skip_bytes(gen_Buffer *buffer, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    buffer->used += (uint32_t)len;
    return true;
}

uint32_t gen_encode_var_u32_raw(uint32_t value, uint8_t out[5]) {
    uint32_t count = 0;
    do {
        uint8_t byte = (uint8_t)(value & 0x7Fu);
        value >>= 7u;
        if (value) { byte |= 0x80u; }
        out[count++] = byte;
    } while (value);
    return count;
}

bool gen_buffer_begin_block(gen_Buffer *buffer, uint32_t *marker) {
    if (buffer->used + 5 > buffer->size) { return false; }
    uint8_t *base = (uint8_t *)buffer->ptr;
    memset(base + buffer->used, 0, 5);
    *marker = buffer->used;
    buffer->used += 5;
    return true;
}

bool gen_buffer_end_block(gen_Buffer *buffer, uint32_t marker) {
    uint32_t payload_start = marker + 5;
    if (buffer->used < payload_start) { return false; }
    uint32_t payload_len = buffer->used - payload_start;
    uint8_t encoded[5];
    uint32_t encoded_len = gen_encode_var_u32_raw(payload_len, encoded);
    uint8_t *base = (uint8_t *)buffer->ptr;
    memmove(base + marker + encoded_len, base + payload_start, payload_len);
    memcpy(base + marker, encoded, encoded_len);
    buffer->used = marker + encoded_len + payload_len;
    return true;
}

bool gen_write_var_u32(gen_Buffer *buffer, uint32_t value);
bool gen_read_var_u32(gen_Buffer *buffer, uint32_t *out);
bool gen_write_var_u64(gen_Buffer *buffer, uint64_t value);
bool gen_read_var_u64(gen_Buffer *buffer, uint64_t *out);
bool gen_write_var_s32(gen_Buffer *buffer, int32_t value);
bool gen_read_var_s32(gen_Buffer *buffer, int32_t *out);
bool gen_write_var_s64(gen_Buffer *buffer, int64_t value);
bool gen_read_var_s64(gen_Buffer *buffer, int64_t *out);

bool gen_buffer_begin_read_block(gen_Buffer *buffer, uint32_t *block_end) {
    if (!block_end) { return false; }
    uint32_t len = 0;
    if (!gen_read_var_u32(buffer, &len)) { return false; }
    if (buffer->used + len > buffer->size) { return false; }
    *block_end = buffer->used + len;
    return true;
}

bool gen_buffer_end_read_block(gen_Buffer *buffer, uint32_t block_end) {
    if (block_end > buffer->size) { return false; }
    if (buffer->used > block_end) { return false; }
    if (buffer->used < block_end) {
        return gen_buffer_skip_bytes(buffer, (size_t)(block_end - buffer->used));
    }
    return true;
}

uint32_t gen_make_wire_tag(uint32_t field_id, gen_wireType wire) {
    return (field_id << 2) | (uint32_t)wire;
}
bool gen_write_wire_tag(gen_Buffer *buffer, uint32_t field_id, gen_wireType wire) {
    return gen_write_var_u32(buffer, gen_make_wire_tag(field_id, wire));
}
bool gen_read_wire_tag(gen_Buffer *buffer, uint32_t *out_field_id, gen_wireType *out_wire) {
    uint32_t raw = 0;
    if (!gen_read_var_u32(buffer, &raw)) { return false; }
    if (raw == 0) { *out_field_id = 0; *out_wire = gen_wireType_Varint; return true; }
    *out_field_id = raw >> 2;
    *out_wire = (gen_wireType)(raw & 0x3u);
    return true;
}

bool gen_skip_wire_value(gen_Buffer *buffer, gen_wireType wire) {
    switch (wire) {
        case gen_wireType_Varint:
        {
            while (true) {
                uint8_t byte = 0;
                if (!gen_buffer_read_u8(buffer, &byte)) { return false; }
                if ((byte & 0x80u) == 0) { break; }
            }
            return true;
        }
        case gen_wireType_Fixed32:
            return gen_buffer_skip_bytes(buffer, 4);
        case gen_wireType_Fixed64:
            return gen_buffer_skip_bytes(buffer, 8);
        case gen_wireType_LengthDelimited:
        {
            uint32_t len = 0;
            if (!gen_read_var_u32(buffer, &len)) { return false; }
            return gen_buffer_skip_bytes(buffer, len);
        }
        default:
            return false;
    }
}

bool gen_buffer_read_string(gen_Buffer *buffer, gen_Buffer *memory, gen_str8 *out) {
    if (!memory) { return false; }
    uint32_t len = 0;
    if (!gen_read_var_u32(buffer, &len)) { return false; }
    if (buffer->used + len > buffer->size) { return false; }
    uint8_t *str = (uint8_t *)gen_buffer_push_aligned(memory, (size_t)len + 1, 1);
    if (!str) { return false; }
    if (!gen_buffer_read_bytes(buffer, str, len)) { return false; }
    str[len] = 0;
    out->content = str;
    out->size = len;
    return true;
}
bool gen_buffer_write_string(gen_Buffer *buffer, const gen_str8 *value) {
    uint64_t len = value ? value->size : 0;
    if (len > UINT32_MAX) { return false; }
    if (!gen_write_var_u32(buffer, (uint32_t)len)) { return false; }
    if (len == 0) { return true; }
    if (!value->content) { return false; }
    return gen_buffer_write_bytes(buffer, value->content, (size_t)len);
}

typedef struct gen_BitWriter {
    uint8_t scratch;
    uint8_t used_bits;
} gen_BitWriter;
typedef struct gen_BitReader {
    uint8_t scratch;
    uint8_t used_bits;
} gen_BitReader;
bool gen_bitwriter_write(gen_BitWriter *bw, gen_Buffer *buffer, uint64_t value, uint32_t width) {
    while (width) {
        uint32_t avail = 8u - bw->used_bits;
        uint32_t take = width < avail ? width : avail;
        uint8_t chunk_mask = (uint8_t)((UINT8_C(1) << take) - 1u);
        bw->scratch |= (uint8_t)((value & chunk_mask) << bw->used_bits);
        bw->used_bits += (uint8_t)take;
        value >>= take;
        width -= take;
        if (bw->used_bits == 8u) {
            if (!gen_buffer_write_u8(buffer, bw->scratch)) { return false; }
            bw->scratch = 0;
            bw->used_bits = 0;
        }
    }
    return true;
}
bool gen_bitwriter_flush(gen_BitWriter *bw, gen_Buffer *buffer) {
    if (bw->used_bits == 0) { return true; }
    bool ok = gen_buffer_write_u8(buffer, bw->scratch);
    bw->scratch = 0;
    bw->used_bits = 0;
    return ok;
}
bool gen_bitreader_read(gen_BitReader *br, gen_Buffer *buffer, uint32_t width, uint64_t *out) {
    uint64_t result = 0;
    uint32_t shift = 0;
    while (width) {
        if (br->used_bits == 8u) {
            if (!gen_buffer_read_u8(buffer, &br->scratch)) { return false; }
            br->used_bits = 0;
        }
        uint32_t avail = 8u - br->used_bits;
        uint32_t take = width < avail ? width : avail;
        uint8_t chunk_mask = (uint8_t)((UINT8_C(1) << take) - 1u);
        uint8_t chunk = (uint8_t)((br->scratch >> br->used_bits) & chunk_mask);
        result |= ((uint64_t)chunk) << shift;
        br->used_bits += (uint8_t)take;
        width -= take;
        shift += take;
    }
    *out = result;
    return true;
}
void gen_bitreader_align(gen_BitReader *br) {
    if (br->used_bits != 0 && br->used_bits < 8u) { br->used_bits = 8u; }
}

uint32_t gen_zigzag32(int32_t value) {
    return ((uint32_t)value << 1) ^ (uint32_t)(value >> 31);
}
int32_t gen_unzigzag32(uint32_t value) {
    return (int32_t)((value >> 1) ^ (~(value & 1) + 1));
}
uint64_t gen_zigzag64(int64_t value) {
    return ((uint64_t)value << 1) ^ (uint64_t)(value >> 63);
}
int64_t gen_unzigzag64(uint64_t value) {
    return (int64_t)((value >> 1) ^ (~(value & 1) + 1));
}

bool gen_write_var_u32(gen_Buffer *buffer, uint32_t value) {
    uint8_t bytes[5];
    uint32_t count = 0;
    do {
        uint8_t byte = (uint8_t)(value & 0x7Fu);
        value >>= 7u;
        if (value) { byte |= 0x80u; }
        bytes[count++] = byte;
    } while (value && count < sizeof(bytes));
    return gen_buffer_write_bytes(buffer, bytes, count);
}
bool gen_read_var_u32(gen_Buffer *buffer, uint32_t *out) {
    uint32_t result = 0;
    uint32_t shift = 0;
    for (uint32_t i = 0; i < 5; ++i) {
        uint8_t byte = 0;
        if (!gen_buffer_read_u8(buffer, &byte)) { return false; }
        result |= ((uint32_t)(byte & 0x7Fu) << shift);
        if ((byte & 0x80u) == 0) { *out = result; return true; }
        shift += 7u;
    }
    return false;
}
bool gen_write_var_u64(gen_Buffer *buffer, uint64_t value) {
    uint8_t bytes[10];
    uint32_t count = 0;
    do {
        uint8_t byte = (uint8_t)(value & 0x7Fu);
        value >>= 7u;
        if (value) { byte |= 0x80u; }
        bytes[count++] = byte;
    } while (value && count < sizeof(bytes));
    return gen_buffer_write_bytes(buffer, bytes, count);
}
bool gen_read_var_u64(gen_Buffer *buffer, uint64_t *out) {
    uint64_t result = 0;
    uint32_t shift = 0;
    for (uint32_t i = 0; i < 10; ++i) {
        uint8_t byte = 0;
        if (!gen_buffer_read_u8(buffer, &byte)) { return false; }
        result |= ((uint64_t)(byte & 0x7Fu) << shift);
        if ((byte & 0x80u) == 0) { *out = result; return true; }
        shift += 7u;
    }
    return false;
}
bool gen_write_var_s32(gen_Buffer *buffer, int32_t value) {
    return gen_write_var_u32(buffer, gen_zigzag32(value));
}
bool gen_read_var_s32(gen_Buffer *buffer, int32_t *out) {
    uint32_t tmp = 0;
    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
    *out = gen_unzigzag32(tmp);
    return true;
}
bool gen_write_var_s64(gen_Buffer *buffer, int64_t value) {
    return gen_write_var_u64(buffer, gen_zigzag64(value));
}
bool gen_read_var_s64(gen_Buffer *buffer, int64_t *out) {
    uint64_t tmp = 0;
    if (!gen_read_var_u64(buffer, &tmp)) { return false; }
    *out = gen_unzigzag64(tmp);
    return true;
}
bool gen_buffer_skip(gen_Buffer *buffer, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    buffer->used += (uint32_t)len;
    return true;
}
bool gen_write_field_header(gen_Buffer *buffer, uint32_t field_id, uint32_t type_code) {
    if (!gen_write_var_u32(buffer, field_id)) { return false; }
    if (field_id == 0) { return true; }
    return gen_write_var_u32(buffer, type_code);
}
bool gen_read_field_header(gen_Buffer *buffer, uint32_t *out_field, uint32_t *out_type) {
    if (!gen_read_var_u32(buffer, out_field)) { return false; }
    if (*out_field == 0) { return true; }
    return gen_read_var_u32(buffer, out_type);
}
float gen_denorm_clamp_f32(float value) {
    if (fabsf(value) < FLT_MIN) { return 0.0f; }
    return value;
}
bool gen_write_compact_f32(gen_Buffer *buffer, float value) {
    float normalized = gen_denorm_clamp_f32(value);
    uint8_t flag = normalized == 0.0f ? 0u : 1u;
    if (!gen_buffer_write_u8(buffer, flag)) { return false; }
    if (!flag) { return true; }
#if gen__IS_BIG_ENDIAN
    uint32_t raw; memcpy(&raw, &normalized, 4); raw = gen__bswap32(raw);
    return gen_buffer_write_bytes(buffer, &raw, sizeof(raw));
#else
    return gen_buffer_write_bytes(buffer, &normalized, sizeof(normalized));
#endif
}
bool gen_read_compact_f32(gen_Buffer *buffer, float *out) {
    uint8_t flag = 0;
    if (!gen_buffer_read_u8(buffer, &flag)) { return false; }
    if (!flag) { *out = 0.0f; return true; }
#if gen__IS_BIG_ENDIAN
    uint32_t raw; if (!gen_buffer_read_bytes(buffer, &raw, sizeof(raw))) return false;
    raw = gen__bswap32(raw); memcpy(out, &raw, 4); return true;
#else
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
#endif
}
bool gen_write_compact_f64(gen_Buffer *buffer, double value) {
    double normalized = fabs(value) < DBL_MIN ? 0.0 : value;
    uint8_t flag = normalized == 0.0 ? 0u : 1u;
    if (!gen_buffer_write_u8(buffer, flag)) { return false; }
    if (!flag) { return true; }
#if gen__IS_BIG_ENDIAN
    uint64_t raw; memcpy(&raw, &normalized, 8); raw = gen__bswap64(raw);
    return gen_buffer_write_bytes(buffer, &raw, sizeof(raw));
#else
    return gen_buffer_write_bytes(buffer, &normalized, sizeof(normalized));
#endif
}
bool gen_read_compact_f64(gen_Buffer *buffer, double *out) {
    uint8_t flag = 0;
    if (!gen_buffer_read_u8(buffer, &flag)) { return false; }
    if (!flag) { *out = 0.0; return true; }
#if gen__IS_BIG_ENDIAN
    uint64_t raw; if (!gen_buffer_read_bytes(buffer, &raw, sizeof(raw))) return false;
    raw = gen__bswap64(raw); memcpy(out, &raw, 8); return true;
#else
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
#endif
}
bool gen_AchievementsArray_read(gen_AchievementsArray *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    uint32_t count = 0;
    if (!gen_buffer_read_u32(buffer, &count)) { return false; }
    value->items = NULL;
    value->count = 0;
    if (count == 0) { return true; }
    const uint32_t memory_marker = memory->used;
    gen_Achievements *items = (gen_Achievements *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_Achievements), (sizeof(gen_Achievements) > sizeof(void *)) ? sizeof(gen_Achievements) : sizeof(void *));
    if (!items) { return false; }
    for (uint32_t i = 0; i < count; ++i) {
        if (!gen_Achievements_read(&items[i], buffer, memory, schema)) {
            gen_buffer_pop_to(memory, memory_marker);
            return false;
        }
    }
    value->items = items;
    value->count = count;
    return true;
}

bool gen_AchievementsArray_write(const gen_AchievementsArray *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->count)) { return false; }
    for (uint32_t i = 0; i < value->count; ++i) {
        if (!gen_Achievements_write(&value->items[i], buffer, schema)) { return false; }
    }
    return true;
}

bool gen_StringAchievementsPairArray_read(gen_StringAchievementsPairArray *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    uint32_t count = 0;
    if (!gen_buffer_read_u32(buffer, &count)) { return false; }
    value->items = NULL;
    value->count = 0;
    if (count == 0) { return true; }
    const uint32_t memory_marker = memory->used;
    gen_StringAchievementsPair *items = (gen_StringAchievementsPair *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_StringAchievementsPair), (sizeof(gen_StringAchievementsPair) > sizeof(void *)) ? sizeof(gen_StringAchievementsPair) : sizeof(void *));
    if (!items) { return false; }
    for (uint32_t i = 0; i < count; ++i) {
        if (!gen_StringAchievementsPair_read(&items[i], buffer, memory, schema)) {
            gen_buffer_pop_to(memory, memory_marker);
            return false;
        }
    }
    value->items = items;
    value->count = count;
    return true;
}

bool gen_StringAchievementsPairArray_write(const gen_StringAchievementsPairArray *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->count)) { return false; }
    for (uint32_t i = 0; i < value->count; ++i) {
        if (!gen_StringAchievementsPair_write(&value->items[i], buffer, schema)) { return false; }
    }
    return true;
}

bool gen_Achievements_read(gen_Achievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (!gen_buffer_read_u32(buffer, &value->questsCompleted)) { return false; }
    if (!gen_buffer_read_u32(buffer, &value->bossesDefeated)) { return false; }
    if (!gen_buffer_read_u16(buffer, &value->secretsFound)) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->rank)) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->prestigeLevel)) { return false; }
    return true;
}

bool gen_Achievements_write(const gen_Achievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->questsCompleted)) { return false; }
    if (!gen_buffer_write_u32(buffer, value->bossesDefeated)) { return false; }
    if (!gen_buffer_write_u16(buffer, value->secretsFound)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->rank)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->prestigeLevel)) { return false; }
    return true;
}

bool gen_PlayerState_read(gen_PlayerState *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    uint8_t bitmask[1];
    if (!gen_buffer_read_bytes(buffer, bitmask, sizeof(bitmask))) { return false; }
    value->yawExist = (bitmask[0] >> 0) & 1u;
    if (value->yawExist) {
        {
            u32 temp;
            if (!gen_buffer_read_u32(buffer, &temp)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(temp)) & mask;
            value->yaw = (u32)masked;
        }
    }
    value->posXExist = (bitmask[0] >> 1) & 1u;
    if (value->posXExist) {
        {
            i32 temp;
            if (!gen_buffer_read_i32(buffer, &temp)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(temp)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posX = (i32)masked;
        }
    }
    value->posYExist = (bitmask[0] >> 2) & 1u;
    if (value->posYExist) {
        {
            i32 temp;
            if (!gen_buffer_read_i32(buffer, &temp)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(temp)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posY = (i32)masked;
        }
    }
    value->posZExist = (bitmask[0] >> 3) & 1u;
    if (value->posZExist) {
        {
            i32 temp;
            if (!gen_buffer_read_i32(buffer, &temp)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(temp)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posZ = (i32)masked;
        }
    }
    return true;
}

bool gen_PlayerState_write(const gen_PlayerState *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    uint8_t bitmask[1];
    memset(bitmask, 0, sizeof(bitmask));
    if (value->yawExist) { bitmask[0] |= (1u << 0); }
    if (value->posXExist) { bitmask[0] |= (1u << 1); }
    if (value->posYExist) { bitmask[0] |= (1u << 2); }
    if (value->posZExist) { bitmask[0] |= (1u << 3); }
    if (!gen_buffer_write_bytes(buffer, bitmask, sizeof(bitmask))) { return false; }
    if (value->yawExist) {
        {
            u32 temp;
            const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->yaw)) & mask;
            temp = (u32)masked;
            if (!gen_buffer_write_u32(buffer, temp)) { return false; }
        }
    }
    if (value->posXExist) {
        {
            i32 temp;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posX)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            temp = (i32)masked;
            if (!gen_buffer_write_i32(buffer, temp)) { return false; }
        }
    }
    if (value->posYExist) {
        {
            i32 temp;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posY)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            temp = (i32)masked;
            if (!gen_buffer_write_i32(buffer, temp)) { return false; }
        }
    }
    if (value->posZExist) {
        {
            i32 temp;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posZ)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            temp = (i32)masked;
            if (!gen_buffer_write_i32(buffer, temp)) { return false; }
        }
    }
    return true;
}

bool gen_StringAchievementsPair_read(gen_StringAchievementsPair *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (!gen_buffer_read_string(buffer, memory, &value->key)) { return false; }
    if (!gen_Achievements_read(&value->value, buffer, memory, schema)) { return false; }
    return true;
}

bool gen_StringAchievementsPair_write(const gen_StringAchievementsPair *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_string(buffer, &value->key)) { return false; }
    if (!gen_Achievements_write(&value->value, buffer, schema)) { return false; }
    return true;
}

bool gen_Player_read(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (!gen_buffer_read_u32(buffer, &value->id)) { return false; }
    {
        uint8_t raw = 0;
        if (!gen_buffer_read_u8(buffer, &raw)) { return false; }
        value->flags = (gen_PlayerFlags)raw;
    }
    {
        u32 raw = 0;
        if (!gen_buffer_read_u32(buffer, &raw)) { return false; }
        value->class = (gen_Class)raw;
    }
    if (!gen_AchievementsArray_read(&value->achievements, buffer, memory, schema)) { return false; }
    if (!gen_buffer_read_u32(buffer, &value->extraSeq3)) { return false; }
    if (!gen_StringAchievementsPairArray_read(&value->map, buffer, memory, schema)) { return false; }
    if (!gen_buffer_read_u32(buffer, &value->extraSeq2)) { return false; }
    return true;
}

bool gen_Player_write(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->id)) { return false; }
    if (!gen_buffer_write_u8(buffer, (uint8_t)value->flags)) { return false; }
    if (!gen_buffer_write_u32(buffer, (u32)value->class)) { return false; }
    if (!gen_AchievementsArray_write(&value->achievements, buffer, schema)) { return false; }
    if (!gen_buffer_write_u32(buffer, value->extraSeq3)) { return false; }
    if (!gen_StringAchievementsPairArray_write(&value->map, buffer, schema)) { return false; }
    if (!gen_buffer_write_u32(buffer, value->extraSeq2)) { return false; }
    return true;
}

static const gen_ParameterInfo gen_Achievements_parameters[] = {
    { "questsCompleted", gen_achievementsParameters_questsCompleted, gen_type_u32, offsetof(gen_Achievements, questsCompleted) },
    { "bossesDefeated", gen_achievementsParameters_bossesDefeated, gen_type_u32, offsetof(gen_Achievements, bossesDefeated) },
    { "secretsFound", gen_achievementsParameters_secretsFound, gen_type_u16, offsetof(gen_Achievements, secretsFound) },
    { "rank", gen_achievementsParameters_rank, gen_type_u8, offsetof(gen_Achievements, rank) },
    { "prestigeLevel", gen_achievementsParameters_prestigeLevel, gen_type_u8, offsetof(gen_Achievements, prestigeLevel) },
};

static const gen_ParameterInfo gen_PlayerState_parameters[] = {
    { "yaw", gen_playerStateParameters_yaw, gen_type_u32, UINT32_MAX },
    { "posX", gen_playerStateParameters_posX, gen_type_i32, UINT32_MAX },
    { "posY", gen_playerStateParameters_posY, gen_type_i32, UINT32_MAX },
    { "posZ", gen_playerStateParameters_posZ, gen_type_i32, UINT32_MAX },
};

static const gen_ParameterInfo gen_StringAchievementsPair_parameters[] = {
    { "key", gen_stringAchievementsPairParameters_key, gen_type_string, offsetof(gen_StringAchievementsPair, key) },
    { "value", gen_stringAchievementsPairParameters_value, gen_type_Achievements, offsetof(gen_StringAchievementsPair, value) },
};

static const gen_ParameterInfo gen_Player_parameters[] = {
    { "id", gen_playerParameters_id, gen_type_u32, offsetof(gen_Player, id) },
    { "flags", gen_playerParameters_flags, gen_type_PlayerFlags, offsetof(gen_Player, flags) },
    { "class", gen_playerParameters_class, gen_type_Class, offsetof(gen_Player, class) },
    { "achievements", gen_playerParameters_achievements, gen_type_ArrayAchievements, offsetof(gen_Player, achievements) },
    { "extraSeq3", gen_playerParameters_extraSeq3, gen_type_u32, offsetof(gen_Player, extraSeq3) },
    { "map", gen_playerParameters_map, gen_type_ArrayStringAchievementsPair, offsetof(gen_Player, map) },
    { "extraSeq2", gen_playerParameters_extraSeq2, gen_type_u32, offsetof(gen_Player, extraSeq2) },
};

static const gen_TypeDescription gen_type_descriptions[] = {
    { "Achievements", gen_type_Achievements, sizeof(gen_Achievements), sizeof(gen_Achievements), gen_Achievements_parameters, 5 },
    { "PlayerState", gen_type_PlayerState, sizeof(gen_PlayerState), sizeof(gen_PlayerState), gen_PlayerState_parameters, 4 },
    { "StringAchievementsPair", gen_type_StringAchievementsPair, sizeof(gen_StringAchievementsPair), sizeof(gen_StringAchievementsPair), gen_StringAchievementsPair_parameters, 2 },
    { "Player", gen_type_Player, sizeof(gen_Player), sizeof(gen_Player), gen_Player_parameters, 7 },
};

const gen_TypeDescription *gen_get_type_description(gen_type type_id) {
    for (size_t i = 0; i < sizeof(gen_type_descriptions)/sizeof(gen_type_descriptions[0]); ++i) {
        if (gen_type_descriptions[i].type_id == type_id) { return &gen_type_descriptions[i]; }
    }
    return NULL;
}
bool gen_Achievements_encode_compact(const gen_Achievements *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_write_var_u32(buffer, (uint32_t)value->questsCompleted)) { return false; }
    if (!gen_write_var_u32(buffer, (uint32_t)value->bossesDefeated)) { return false; }
    if (!gen_write_var_u32(buffer, (uint32_t)value->secretsFound)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->rank)) { return false; }
    if (!gen_buffer_write_u8(buffer, value->prestigeLevel)) { return false; }
    return true;
}

bool gen_Achievements_decode_compact(gen_Achievements *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (schema) {
        const gen_SchemaType *type = NULL;
        for (uint32_t i = 0; i < schema->type_count; ++i) {
            if (strcmp(schema->types[i].name, "Achievements") == 0) {
                type = &schema->types[i];
                break;
            }
        }
        if (!type) return false;
        uint32_t optional_count = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            if (type->fields[i].is_optional) optional_count++;
        }
        uint8_t mask_buf[128];
        uint8_t *bitmask = NULL;
        if (optional_count > 0) {
            uint32_t bytes = (optional_count + 7) / 8;
            if (bytes > sizeof(mask_buf)) return false;
            if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
            bitmask = mask_buf;
        }
        uint32_t opt_idx = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            bool present = true;
            if (type->fields[i].is_optional) {
                present = (bitmask[opt_idx / 8] >> (opt_idx % 8)) & 1;
                opt_idx++;
            }
            if (!present) continue;
            switch (type->fields[i].mapping) {
                case gen_achievementsParameters_questsCompleted: {
                    {
                        uint32_t tmp = 0;
                        if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                        value->questsCompleted = (uint32_t)tmp;
                    }
                    break;
                }
                case gen_achievementsParameters_bossesDefeated: {
                    {
                        uint32_t tmp = 0;
                        if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                        value->bossesDefeated = (uint32_t)tmp;
                    }
                    break;
                }
                case gen_achievementsParameters_secretsFound: {
                    {
                        uint32_t tmp = 0;
                        if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                        value->secretsFound = (uint32_t)tmp;
                    }
                    break;
                }
                case gen_achievementsParameters_rank: {
                    if (!gen_buffer_read_u8(buffer, &value->rank)) { return false; }
                    break;
                }
                case gen_achievementsParameters_prestigeLevel: {
                    if (!gen_buffer_read_u8(buffer, &value->prestigeLevel)) { return false; }
                    break;
                }
                default:
                    if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
                    break;
            }
        }
        return true;
    }

    {
        uint32_t tmp = 0;
        if (!gen_read_var_u32(buffer, &tmp)) { return false; }
        value->questsCompleted = (uint32_t)tmp;
    }
    {
        uint32_t tmp = 0;
        if (!gen_read_var_u32(buffer, &tmp)) { return false; }
        value->bossesDefeated = (uint32_t)tmp;
    }
    {
        uint32_t tmp = 0;
        if (!gen_read_var_u32(buffer, &tmp)) { return false; }
        value->secretsFound = (uint32_t)tmp;
    }
    if (!gen_buffer_read_u8(buffer, &value->rank)) { return false; }
    if (!gen_buffer_read_u8(buffer, &value->prestigeLevel)) { return false; }
    return true;
}

bool gen_Achievements_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_wireType wire = gen_wireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

bool gen_PlayerState_encode_compact(const gen_PlayerState *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    uint8_t bitmask[1];
    memset(bitmask, 0, sizeof(bitmask));
    if (value->yawExist) { bitmask[0] |= (1u << 0); }
    if (value->posXExist) { bitmask[0] |= (1u << 1); }
    if (value->posYExist) { bitmask[0] |= (1u << 2); }
    if (value->posZExist) { bitmask[0] |= (1u << 3); }
    if (!gen_buffer_write_bytes(buffer, bitmask, sizeof(bitmask))) { return false; }
    gen_BitWriter bit_writer = {0, 0};
    if (value->yawExist) {
        {
        u32 bw_value;
            const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->yaw)) & mask;
            bw_value = (u32)masked;
            if (!gen_bitwriter_write(&bit_writer, buffer, (uint64_t)bw_value, 10)) { return false; }
        }
    }
    if (value->posXExist) {
        {
        i32 bw_value;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posX)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            bw_value = (i32)masked;
            if (!gen_bitwriter_write(&bit_writer, buffer, (uint64_t)bw_value, 20)) { return false; }
        }
    }
    if (value->posYExist) {
        {
        i32 bw_value;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posY)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            bw_value = (i32)masked;
            if (!gen_bitwriter_write(&bit_writer, buffer, (uint64_t)bw_value, 20)) { return false; }
        }
    }
    if (value->posZExist) {
        {
        i32 bw_value;
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(value->posZ)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            bw_value = (i32)masked;
            if (!gen_bitwriter_write(&bit_writer, buffer, (uint64_t)bw_value, 20)) { return false; }
        }
    }
    if (!gen_bitwriter_flush(&bit_writer, buffer)) { return false; }
    return true;
}

bool gen_PlayerState_decode_compact(gen_PlayerState *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    gen_BitReader bit_reader = {0, 8};
    if (schema) {
        const gen_SchemaType *type = NULL;
        for (uint32_t i = 0; i < schema->type_count; ++i) {
            if (strcmp(schema->types[i].name, "PlayerState") == 0) {
                type = &schema->types[i];
                break;
            }
        }
        if (!type) return false;
        uint32_t optional_count = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            if (type->fields[i].is_optional) optional_count++;
        }
        uint8_t mask_buf[128];
        uint8_t *bitmask = NULL;
        if (optional_count > 0) {
            uint32_t bytes = (optional_count + 7) / 8;
            if (bytes > sizeof(mask_buf)) return false;
            if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
            bitmask = mask_buf;
        }
        uint32_t opt_idx = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            bool present = true;
            if (type->fields[i].is_optional) {
                present = (bitmask[opt_idx / 8] >> (opt_idx % 8)) & 1;
                opt_idx++;
            }
            if (type->fields[i].bit_width == 0) { gen_bitreader_align(&bit_reader); }
            if (!present) continue;
            switch (type->fields[i].mapping) {
                case gen_playerStateParameters_yaw: {
                    value->yawExist = true;
                    {
                        uint64_t bw_raw = 0;
                        if (!gen_bitreader_read(&bit_reader, buffer, 10, &bw_raw)) { return false; }
                        const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
                        uint64_t masked = ((uint64_t)(bw_raw)) & mask;
                        value->yaw = (u32)masked;
                    }
                    break;
                }
                case gen_playerStateParameters_posX: {
                    value->posXExist = true;
                    {
                        uint64_t bw_raw = 0;
                        if (!gen_bitreader_read(&bit_reader, buffer, 20, &bw_raw)) { return false; }
                        const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
                        uint64_t masked = ((uint64_t)(bw_raw)) & mask;
                        const uint64_t sign_bit = UINT64_C(1) << 19;
                        if (masked & sign_bit) { masked |= ~mask; }
                        value->posX = (i32)masked;
                    }
                    break;
                }
                case gen_playerStateParameters_posY: {
                    value->posYExist = true;
                    {
                        uint64_t bw_raw = 0;
                        if (!gen_bitreader_read(&bit_reader, buffer, 20, &bw_raw)) { return false; }
                        const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
                        uint64_t masked = ((uint64_t)(bw_raw)) & mask;
                        const uint64_t sign_bit = UINT64_C(1) << 19;
                        if (masked & sign_bit) { masked |= ~mask; }
                        value->posY = (i32)masked;
                    }
                    break;
                }
                case gen_playerStateParameters_posZ: {
                    value->posZExist = true;
                    {
                        uint64_t bw_raw = 0;
                        if (!gen_bitreader_read(&bit_reader, buffer, 20, &bw_raw)) { return false; }
                        const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
                        uint64_t masked = ((uint64_t)(bw_raw)) & mask;
                        const uint64_t sign_bit = UINT64_C(1) << 19;
                        if (masked & sign_bit) { masked |= ~mask; }
                        value->posZ = (i32)masked;
                    }
                    break;
                }
                default:
                    if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
                    break;
            }
        }
        return true;
    }

    uint8_t bitmask[1];
    if (!gen_buffer_read_bytes(buffer, bitmask, sizeof(bitmask))) { return false; }
    value->yawExist = (bitmask[0] >> 0) & 1u;
    if (value->yawExist) {
        {
            uint64_t bw_raw = 0;
            if (!gen_bitreader_read(&bit_reader, buffer, 10, &bw_raw)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 10) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(bw_raw)) & mask;
            value->yaw = (u32)masked;
        }
    }
    value->posXExist = (bitmask[0] >> 1) & 1u;
    if (value->posXExist) {
        {
            uint64_t bw_raw = 0;
            if (!gen_bitreader_read(&bit_reader, buffer, 20, &bw_raw)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(bw_raw)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posX = (i32)masked;
        }
    }
    value->posYExist = (bitmask[0] >> 2) & 1u;
    if (value->posYExist) {
        {
            uint64_t bw_raw = 0;
            if (!gen_bitreader_read(&bit_reader, buffer, 20, &bw_raw)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(bw_raw)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posY = (i32)masked;
        }
    }
    value->posZExist = (bitmask[0] >> 3) & 1u;
    if (value->posZExist) {
        {
            uint64_t bw_raw = 0;
            if (!gen_bitreader_read(&bit_reader, buffer, 20, &bw_raw)) { return false; }
            const uint64_t mask = ((UINT64_C(1) << 20) - UINT64_C(1));
            uint64_t masked = ((uint64_t)(bw_raw)) & mask;
            const uint64_t sign_bit = UINT64_C(1) << 19;
            if (masked & sign_bit) { masked |= ~mask; }
            value->posZ = (i32)masked;
        }
    }
    return true;
}

bool gen_PlayerState_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_wireType wire = gen_wireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

bool gen_StringAchievementsPair_encode_compact(const gen_StringAchievementsPair *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_string(buffer, &value->key)) { return false; }
    if (!gen_Achievements_encode_compact(&value->value, buffer, schema)) { return false; }
    return true;
}

bool gen_StringAchievementsPair_decode_compact(gen_StringAchievementsPair *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (schema) {
        const gen_SchemaType *type = NULL;
        for (uint32_t i = 0; i < schema->type_count; ++i) {
            if (strcmp(schema->types[i].name, "StringAchievementsPair") == 0) {
                type = &schema->types[i];
                break;
            }
        }
        if (!type) return false;
        uint32_t optional_count = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            if (type->fields[i].is_optional) optional_count++;
        }
        uint8_t mask_buf[128];
        uint8_t *bitmask = NULL;
        if (optional_count > 0) {
            uint32_t bytes = (optional_count + 7) / 8;
            if (bytes > sizeof(mask_buf)) return false;
            if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
            bitmask = mask_buf;
        }
        uint32_t opt_idx = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            bool present = true;
            if (type->fields[i].is_optional) {
                present = (bitmask[opt_idx / 8] >> (opt_idx % 8)) & 1;
                opt_idx++;
            }
            if (!present) continue;
            switch (type->fields[i].mapping) {
                case gen_stringAchievementsPairParameters_key: {
                    if (!gen_buffer_read_string(buffer, memory, &value->key)) { return false; }
                    break;
                }
                case gen_stringAchievementsPairParameters_value: {
                    if (!gen_Achievements_decode_compact(&value->value, buffer, memory, schema)) { return false; }
                    break;
                }
                default:
                    if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
                    break;
            }
        }
        return true;
    }

    if (!gen_buffer_read_string(buffer, memory, &value->key)) { return false; }
    if (!gen_Achievements_decode_compact(&value->value, buffer, memory, NULL)) { return false; }
    return true;
}

bool gen_StringAchievementsPair_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_wireType wire = gen_wireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

bool gen_Player_encode_compact(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (true) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_id, gen_wireType_Varint)) { return false; }
        if (!gen_write_var_u32(buffer, (uint32_t)value->id)) { return false; }
    }
    if (true) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_flags, gen_wireType_Varint)) { return false; }
        if (!gen_buffer_write_u8(buffer, value->flags)) { return false; }
    }
    if (true) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_class, gen_wireType_Varint)) { return false; }
        if (!gen_write_var_u32(buffer, (uint32_t)value->class)) { return false; }
    }
    if (value->achievements.count > 0) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_achievements, gen_wireType_LengthDelimited)) { return false; }
        uint32_t block_marker = 0;
        if (!gen_buffer_begin_block(buffer, &block_marker)) { return false; }
        if (!gen_write_var_u32(buffer, value->achievements.count)) { return false; }
        for (uint32_t i = 0; i < value->achievements.count; ++i) {
            if (!gen_Achievements_encode_compact(&value->achievements.items[i], buffer, schema)) { return false; }
        }
        if (!gen_buffer_end_block(buffer, block_marker)) { return false; }
    }
    if (true) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_extraSeq3, gen_wireType_Varint)) { return false; }
        if (!gen_write_var_u32(buffer, (uint32_t)value->extraSeq3)) { return false; }
    }
    if (value->map.count > 0) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_map, gen_wireType_LengthDelimited)) { return false; }
        uint32_t block_marker = 0;
        if (!gen_buffer_begin_block(buffer, &block_marker)) { return false; }
        if (!gen_write_var_u32(buffer, value->map.count)) { return false; }
        for (uint32_t i = 0; i < value->map.count; ++i) {
            if (!gen_StringAchievementsPair_encode_compact(&value->map.items[i], buffer, schema)) { return false; }
        }
        if (!gen_buffer_end_block(buffer, block_marker)) { return false; }
    }
    if (true) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_extraSeq2, gen_wireType_Varint)) { return false; }
        if (!gen_write_var_u32(buffer, (uint32_t)value->extraSeq2)) { return false; }
    }
    if (!gen_write_var_u32(buffer, 0)) { return false; }
    return true;
}

bool gen_Player_decode_compact(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    while (true) {
        uint32_t field_id = 0;
        gen_wireType wire = gen_wireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        switch (field_id) {
            case gen_playerParameters_id: {
                {
                    uint32_t tmp = 0;
                    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                    value->id = (uint32_t)tmp;
                }
                break;
            }
            case gen_playerParameters_flags: {
                if (!gen_buffer_read_u8(buffer, &value->flags)) { return false; }
                break;
            }
            case gen_playerParameters_class: {
                {
                    uint32_t tmp = 0;
                    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                    value->class = (uint32_t)tmp;
                }
                break;
            }
            case gen_playerParameters_achievements: {
                if (wire != gen_wireType_LengthDelimited) { return false; }
                uint32_t block_end = 0;
                if (!gen_buffer_begin_read_block(buffer, &block_end)) { return false; }
                uint32_t count = 0;
                if (!gen_read_var_u32(buffer, &count)) { return false; }
                value->achievements.items = NULL;
                value->achievements.count = 0;
                if (count) {
                    const uint32_t memory_marker = memory->used;
                    gen_Achievements *items = (gen_Achievements *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_Achievements), (sizeof(gen_Achievements) > sizeof(void *)) ? sizeof(gen_Achievements) : sizeof(void *));
                    if (!items) { return false; }
                    for (uint32_t i = 0; i < count; ++i) {
                        if (!gen_Achievements_decode_compact(&items[i], buffer, memory, schema)) {
                            gen_buffer_pop_to(memory, memory_marker);
                            return false;
                        }
                    }
                    value->achievements.items = items;
                    value->achievements.count = count;
                }
                if (!gen_buffer_end_read_block(buffer, block_end)) { return false; }
                break;
            }
            case gen_playerParameters_extraSeq3: {
                {
                    uint32_t tmp = 0;
                    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                    value->extraSeq3 = (uint32_t)tmp;
                }
                break;
            }
            case gen_playerParameters_map: {
                if (wire != gen_wireType_LengthDelimited) { return false; }
                uint32_t block_end = 0;
                if (!gen_buffer_begin_read_block(buffer, &block_end)) { return false; }
                uint32_t count = 0;
                if (!gen_read_var_u32(buffer, &count)) { return false; }
                value->map.items = NULL;
                value->map.count = 0;
                if (count) {
                    const uint32_t memory_marker = memory->used;
                    gen_StringAchievementsPair *items = (gen_StringAchievementsPair *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_StringAchievementsPair), (sizeof(gen_StringAchievementsPair) > sizeof(void *)) ? sizeof(gen_StringAchievementsPair) : sizeof(void *));
                    if (!items) { return false; }
                    for (uint32_t i = 0; i < count; ++i) {
                        if (!gen_StringAchievementsPair_decode_compact(&items[i], buffer, memory, schema)) {
                            gen_buffer_pop_to(memory, memory_marker);
                            return false;
                        }
                    }
                    value->map.items = items;
                    value->map.count = count;
                }
                if (!gen_buffer_end_read_block(buffer, block_end)) { return false; }
                break;
            }
            case gen_playerParameters_extraSeq2: {
                {
                    uint32_t tmp = 0;
                    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                    value->extraSeq2 = (uint32_t)tmp;
                }
                break;
            }
            default:
                if (!gen_skip_wire_value(buffer, wire)) { return false; }
                break;
        }
    }
    return true;
}

bool gen_Player_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_wireType wire = gen_wireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

#define gen_BINARY_MAGIC "BKIW"
#define gen_BINARY_VERSION 3

const uint8_t gen_schema_blob[] = {

    0x42, 0x4b, 0x49, 0x57, 0x03, 0x06, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x00, 0x00, 0x0c, 0x00, 0x50, 
    0x6c, 0x61, 0x79, 0x65, 0x72, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x00, 0x00, 0x0d, 0x00, 0x41, 0x63, 
    0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x00, 0x01, 0x0e, 0x05, 0x71, 0x75, 
    0x65, 0x73, 0x74, 0x73, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x00, 0x00, 0x02, 
    0x00, 0x00, 0x62, 0x6f, 0x73, 0x73, 0x65, 0x73, 0x44, 0x65, 0x66, 0x65, 0x61, 0x74, 0x65, 0x64, 
    0x00, 0x01, 0x02, 0x00, 0x00, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x73, 0x46, 0x6f, 0x75, 0x6e, 
    0x64, 0x00, 0x02, 0x01, 0x00, 0x00, 0x72, 0x61, 0x6e, 0x6b, 0x00, 0x03, 0x00, 0x00, 0x00, 0x70, 
    0x72, 0x65, 0x73, 0x74, 0x69, 0x67, 0x65, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x00, 0x04, 0x00, 0x00, 
    0x00, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x01, 0x0f, 0x04, 
    0x79, 0x61, 0x77, 0x00, 0x00, 0x02, 0x02, 0x0a, 0x70, 0x6f, 0x73, 0x58, 0x00, 0x01, 0x06, 0x02, 
    0x14, 0x70, 0x6f, 0x73, 0x59, 0x00, 0x02, 0x06, 0x02, 0x14, 0x70, 0x6f, 0x73, 0x5a, 0x00, 0x03, 
    0x06, 0x02, 0x14, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 
    0x6d, 0x65, 0x6e, 0x74, 0x73, 0x50, 0x61, 0x69, 0x72, 0x00, 0x01, 0x10, 0x02, 0x6b, 0x65, 0x79, 
    0x00, 0x00, 0x0b, 0x00, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x01, 0x0e, 0x00, 0x00, 0x50, 
    0x6c, 0x61, 0x79, 0x65, 0x72, 0x00, 0x02, 0x11, 0x08, 0x69, 0x64, 0x00, 0x01, 0x02, 0x00, 0x00, 
    0x66, 0x6c, 0x61, 0x67, 0x73, 0x00, 0x02, 0x0d, 0x00, 0x00, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x00, 
    0x03, 0x0c, 0x00, 0x00, 0x61, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 
    0x00, 0x04, 0x0e, 0x01, 0x00, 0x65, 0x78, 0x74, 0x72, 0x61, 0x53, 0x65, 0x71, 0x33, 0x00, 0x07, 
    0x02, 0x00, 0x00, 0x6d, 0x61, 0x70, 0x00, 0x08, 0x10, 0x01, 0x00, 0x65, 0x78, 0x74, 0x72, 0x61, 
    0x53, 0x65, 0x71, 0x32, 0x00, 0x06, 0x02, 0x04, 0x00, 0x65, 0x78, 0x74, 0x72, 0x61, 0x53, 0x65, 
    0x71, 0x00, 0x05, 0x02, 0x08, 0x00, 
};

static const char *gen_read_strz(const uint8_t **cursor, const uint8_t *end) {
    const char *str = (const char *)*cursor;
    while (*cursor < end && **cursor != 0) { (*cursor)++; }
    if (*cursor < end) { (*cursor)++; return str; }
    return "";
}

static uint64_t gen_read_varuint(const uint8_t **cursor, const uint8_t *end) {
    uint64_t result = 0;
    uint32_t shift = 0;
    while (*cursor < end) {
        uint8_t byte = *(*cursor)++;
        result |= ((uint64_t)(byte & 0x7F) << shift);
        if ((byte & 0x80) == 0) { break; }
        shift += 7;
    }
    return result;
}

const gen_SchemaInfo *gen_parse_schema(const uint8_t *data, size_t size, gen_Buffer *allocator) {
    if (!data || !allocator) return NULL;
    const uint8_t *cursor = data;
    const uint8_t *end = data + size;
    if (size < 5 || memcmp(cursor, gen_BINARY_MAGIC, 4) != 0) return NULL;
    cursor += 4;
    uint8_t version = *cursor++;
    if (version != gen_BINARY_VERSION && version != 2) return NULL;
    
    uint64_t count = gen_read_varuint(&cursor, end);
    gen_SchemaInfo *info = (gen_SchemaInfo *)gen_buffer_push_aligned(allocator, sizeof(gen_SchemaInfo), sizeof(void*));
    if (!info) return NULL;
    info->version = version;
    info->type_count = (uint32_t)count;
    info->types = (gen_SchemaType *)gen_buffer_push_aligned(allocator, sizeof(gen_SchemaType) * count, sizeof(void*));
    if (!info->types) return NULL;
    
    for (uint32_t i = 0; i < count; ++i) {
        gen_SchemaType *type = &info->types[i];
        type->name = gen_read_strz(&cursor, end);
        type->kind = *cursor++;
        type->type_id = (uint32_t)gen_read_varuint(&cursor, end);
        uint64_t fcount = gen_read_varuint(&cursor, end);
        type->field_count = (uint32_t)fcount;
        if (fcount > 0) {
            type->fields = (gen_SchemaField *)gen_buffer_push_aligned(allocator, sizeof(gen_SchemaField) * fcount, sizeof(void*));
            if (!type->fields) return NULL;
            for (uint32_t j = 0; j < fcount; ++j) {
                type->fields[j].name = gen_read_strz(&cursor, end);
                type->fields[j].id = (uint32_t)gen_read_varuint(&cursor, end);
                type->fields[j].type_id = (uint32_t)gen_read_varuint(&cursor, end);
                uint8_t flags = *cursor++;
                type->fields[j].bit_width = (uint32_t)gen_read_varuint(&cursor, end);
                type->fields[j].is_array = (flags & 1) != 0;
                type->fields[j].is_optional = (flags & 2) != 0;
                type->fields[j].is_deprecated = (flags & 4) != 0;
                type->fields[j].is_removed = (flags & 8) != 0;
                type->fields[j].mapping = -1;
            }
        } else {
            type->fields = NULL;
        }
    }
    
    // Resolve schema against local types
    for (uint32_t i = 0; i < info->type_count; ++i) {
        gen_SchemaType *type = &info->types[i];
        const gen_TypeDescription *desc = NULL;
        for (size_t j = 0; j < sizeof(gen_type_descriptions)/sizeof(gen_type_descriptions[0]); ++j) {
            if (strcmp(gen_type_descriptions[j].name, type->name) == 0) {
                desc = &gen_type_descriptions[j];
                break;
            }
        }
        if (!desc) continue;
        
        for (uint32_t j = 0; j < type->field_count; ++j) {
            gen_SchemaField *field = &type->fields[j];
            if (field->is_removed) continue;
            for (uint32_t k = 0; k < desc->parameter_count; ++k) {
                if (strcmp(desc->parameters[k].name, field->name) == 0) {
                    field->mapping = (int32_t)desc->parameters[k].parameter_id;
                    break;
                }
            }
        }
    }
    return info;
}

const uint8_t *gen_get_schema_blob(size_t *out_size) {
    if (out_size) { *out_size = sizeof(gen_schema_blob); }
    return gen_schema_blob;
}

const gen_SchemaInfo *gen_get_embedded_schema(gen_Buffer *allocator) {
    return gen_parse_schema(gen_schema_blob, sizeof(gen_schema_blob), allocator);
}

bool gen_skip_generic(gen_Buffer *buffer, uint32_t type_id, bool is_array, const gen_SchemaInfo *schema) {
    if (is_array) {
        uint32_t count = 0;
        if (!gen_read_var_u32(buffer, &count)) return false;
        for (uint32_t i = 0; i < count; ++i) {
            if (!gen_skip_generic(buffer, type_id, false, schema)) return false;
        }
        return true;
    }
    // Builtins
    if (type_id < 11) {
        switch (type_id) {
            case 0: // u8
            case 4: // i8
            case 10: // bool
                return gen_buffer_skip_bytes(buffer, 1);
            case 1: // u16
            case 2: // u32
            case 5: // i16
            case 6: // i32
            {
                uint32_t tmp; return gen_read_var_u32(buffer, &tmp);
            }
            case 3: // u64
            case 7: // i64
            {
                uint64_t tmp; return gen_read_var_u64(buffer, &tmp);
            }
            case 8: // f32
            {
                float tmp; return gen_read_compact_f32(buffer, &tmp);
            }
            case 9: // f64
            {
                double tmp; return gen_read_compact_f64(buffer, &tmp);
            }
        }
        return false;
    }
    // Look up in schema
    if (!schema) return false;
    const gen_SchemaType *type = NULL;
    for (uint32_t i = 0; i < schema->type_count; ++i) {
        if (schema->types[i].type_id == type_id) {
            type = &schema->types[i];
            break;
        }
    }
    if (!type) return false;
    
    if (type->kind == 0) { // ENUM
        uint32_t tmp; return gen_read_var_u32(buffer, &tmp);
    }
    
    // STRUCT or MESSAGE
    if (type->kind == 2) { // MESSAGE
        // Messages are length-delimited; skip fields until the terminator tag.
        while (true) {
            uint32_t field_id = 0;
            gen_wireType wire = gen_wireType_Varint;
            if (!gen_read_wire_tag(buffer, &field_id, &wire)) return false;
            if (field_id == 0) break;
            if (!gen_skip_wire_value(buffer, wire)) return false;
        }
        return true;
    }
    
    // STRUCT
    // Read bitmask for optional fields
    uint32_t optional_count = 0;
    bool has_bitfields = false;
    for (uint32_t i = 0; i < type->field_count; ++i) {
        if (type->fields[i].is_removed) continue;
        if (type->fields[i].is_optional) optional_count++;
        if (type->fields[i].bit_width > 0) has_bitfields = true;
    }
    gen_BitReader bit_reader = {0, 8};
    uint8_t *bitmask = NULL;
    if (optional_count > 0) {
        uint32_t bytes = (optional_count + 7) / 8;
        if (bytes > 128) return false;
        uint8_t mask_buf[128];
        if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
        bitmask = mask_buf;
    }
    
    uint32_t opt_idx = 0;
    for (uint32_t i = 0; i < type->field_count; ++i) {
        if (type->fields[i].is_removed) continue;
        bool present = true;
        if (type->fields[i].is_optional) {
            present = (bitmask[opt_idx / 8] >> (opt_idx        )) & 1;
            opt_idx++;
        }
        if (has_bitfields && type->fields[i].bit_width == 0) { gen_bitreader_align(&bit_reader); }
        if (present) {
            if (type->fields[i].bit_width > 0) {
                uint64_t tmp = 0;
                if (!gen_bitreader_read(&bit_reader, buffer, type->fields[i].bit_width, &tmp)) return false;
            } else if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
        }
    }
    return true;
}

#endif /* GEN__IMPLEMENTATION */
