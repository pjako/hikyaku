// Generated by schema_gen from map_test.hischema
#ifndef GEN__H_INCLUDE
#define GEN__H_INCLUDE

// To create the implementation, define GEN__IMPLEMENTATION before including this file in one translation unit.

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef GEN__API
#  ifdef GEN__STATIC
#    define GEN__API static
#  else
#    define GEN__API extern
#  endif
#endif

#ifndef GEN_DEPRECATED
#  if defined(__GNUC__) || defined(__clang__)
#    define GEN_DEPRECATED(msg) __attribute__((deprecated(msg)))
#  else
#    define GEN_DEPRECATED(msg)
#  endif
#endif

#if defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#  define gen__IS_BIG_ENDIAN 1
#elif defined(__BIG_ENDIAN__)
#  define gen__IS_BIG_ENDIAN 1
#else
#  define gen__IS_BIG_ENDIAN 0
#endif

#if gen__IS_BIG_ENDIAN
#  ifdef _MSC_VER
#    include <stdlib.h>
#    define gen__bswap16(x) _byteswap_ushort(x)
#    define gen__bswap32(x) _byteswap_ulong(x)
#    define gen__bswap64(x) _byteswap_uint64(x)
#  elif defined(__GNUC__) || defined(__clang__)
#    define gen__bswap16(x) __builtin_bswap16(x)
#    define gen__bswap32(x) __builtin_bswap32(x)
#    define gen__bswap64(x) __builtin_bswap64(x)
#  else
     static inline uint16_t gen__bswap16(uint16_t x) { return (x >> 8) | (x << 8); }
     static inline uint32_t gen__bswap32(uint32_t x) { return ((x >> 24) & 0xff) | ((x >> 8) & 0xff00) | ((x << 8) & 0xff0000) | ((x << 24) & 0xff000000); }
     static inline uint64_t gen__bswap64(uint64_t x) { return ((x >> 56) & 0xff) | ((x >> 40) & 0xff00) | ((x >> 24) & 0xff0000) | ((x >> 8) & 0xff000000) | ((x << 8) & 0xff00000000) | ((x << 24) & 0xff0000000000) | ((x << 40) & 0xff000000000000) | ((x << 56) & 0xff00000000000000); }
#  endif
#endif

typedef struct gen_Buffer {
    void *ptr;
    uint32_t size;
    uint32_t used;
} gen_Buffer;

typedef struct gen_SchemaInfo gen_SchemaInfo;

typedef struct gen_str8 {
    uint8_t *content;
    uint64_t size;
} gen_str8;

GEN__API void gen_buffer_init(gen_Buffer *buffer, void *ptr, uint32_t size);
typedef enum gen_wireType {
    gen_wireType_Varint = 0,
    gen_wireType_Fixed32 = 1,
    gen_wireType_Fixed64 = 2,
    gen_wireType_LengthDelimited = 3,
} gen_wireType;

typedef struct gen_Achievement gen_Achievement;
typedef struct gen_StringAchievementPair gen_StringAchievementPair;
typedef struct gen_Player gen_Player;

typedef struct gen_AchievementArray gen_AchievementArray;
typedef struct gen_StringAchievementPairArray gen_StringAchievementPairArray;

struct gen_AchievementArray {
    gen_Achievement *items;
    uint32_t count;
};

struct gen_StringAchievementPairArray {
    gen_StringAchievementPair *items;
    uint32_t count;
};

struct gen_Achievement {
    uint32_t achievementId;
};

struct gen_StringAchievementPair {
    gen_str8 key;
    gen_Achievement value;
};

struct gen_Player {
    bool idExist;
    uint32_t id;
    bool colorsExist;
    gen_AchievementArray colors;
    bool achievementsExist;
    gen_StringAchievementPairArray achievements;
};

GEN__API bool gen_AchievementArray_read(gen_AchievementArray *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_AchievementArray_write(const gen_AchievementArray *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementPairArray_read(gen_StringAchievementPairArray *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementPairArray_write(const gen_StringAchievementPairArray *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievement_read(gen_Achievement *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievement_write(const gen_Achievement *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementPair_read(gen_StringAchievementPair *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementPair_write(const gen_StringAchievementPair *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_read(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_write(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);

typedef enum gen_type {
    gen_type_u8,
    gen_type_u16,
    gen_type_u32,
    gen_type_u64,
    gen_type_i8,
    gen_type_i16,
    gen_type_i32,
    gen_type_i64,
    gen_type_f32,
    gen_type_f64,
    gen_type_bool,
    gen_type_string,
    gen_type_Achievement,
    gen_type_StringAchievementPair,
    gen_type_Player,
    gen_type_ArrayAchievement,
    gen_type_ArrayStringAchievementPair,
} gen_type;

typedef struct gen_ParameterInfo {
    const char *name;
    uint32_t parameter_id;
    gen_type type_id;
    uint32_t offset;
} gen_ParameterInfo;

typedef struct gen_TypeDescription {
    const char *name;
    gen_type type_id;
    size_t struct_size;
    size_t no_padding_struct_size;
    const gen_ParameterInfo *parameters;
    uint32_t parameter_count;
} gen_TypeDescription;

typedef enum gen_achievementParameters {
    gen_achievementParameters_achievementId = 0,
} gen_achievementParameters;

typedef enum gen_stringAchievementPairParameters {
    gen_stringAchievementPairParameters_key = 0,
    gen_stringAchievementPairParameters_value = 1,
} gen_stringAchievementPairParameters;

typedef enum gen_playerParameters {
    gen_playerParameters_id = 1,
    gen_playerParameters_colors = 4,
    gen_playerParameters_achievements = 8,
} gen_playerParameters;

GEN__API const gen_TypeDescription *gen_get_type_description(gen_type type_id);
GEN__API bool gen_Achievement_encode_compact(const gen_Achievement *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievement_decode_compact(gen_Achievement *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Achievement_skip_compact(gen_Buffer *buffer);

GEN__API bool gen_StringAchievementPair_encode_compact(const gen_StringAchievementPair *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementPair_decode_compact(gen_StringAchievementPair *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_StringAchievementPair_skip_compact(gen_Buffer *buffer);

GEN__API bool gen_Player_encode_compact(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_decode_compact(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema);
GEN__API bool gen_Player_skip_compact(gen_Buffer *buffer);

typedef struct gen_SchemaField {
    const char *name;
    uint32_t id;
    uint32_t type_id;
    uint32_t bit_width;
    bool is_array;
    bool is_optional;
    bool is_deprecated;
    bool is_removed;
    int32_t mapping;
} gen_SchemaField;

typedef struct gen_SchemaType {
    const char *name;
    uint8_t kind; // 0=ENUM, 1=STRUCT, 2=MESSAGE, 3=UNION
    uint32_t type_id;
    uint32_t tag_type_id; // only for unions
    gen_SchemaField *fields;
    uint32_t field_count;
} gen_SchemaType;

struct gen_SchemaInfo {
    uint8_t version;
    gen_SchemaType *types;
    uint32_t type_count;
};

GEN__API const gen_SchemaInfo *gen_parse_schema(const uint8_t *data, size_t size, gen_Buffer *allocator);
GEN__API const uint8_t *gen_get_schema_blob(size_t *out_size);
GEN__API const gen_SchemaInfo *gen_get_embedded_schema(gen_Buffer *allocator);
GEN__API bool gen_skip_generic(gen_Buffer *buffer, uint32_t type_id, bool is_array, const gen_SchemaInfo *schema);
#ifdef __cplusplus
}
#endif

#endif /* GEN__H_INCLUDE */

#ifdef GEN__IMPLEMENTATION

void gen_buffer_init(gen_Buffer *buffer, void *ptr, uint32_t size) {
    buffer->ptr = ptr;
    buffer->size = size;
    buffer->used = 0;
}

bool gen_buffer_read_bytes(gen_Buffer *buffer, void *dst, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    const uint8_t *base = (const uint8_t *)buffer->ptr;
    memcpy(dst, base + buffer->used, len);
    buffer->used += (uint32_t)len;
    return true;
}

bool gen_buffer_write_bytes(gen_Buffer *buffer, const void *src, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    uint8_t *base = (uint8_t *)buffer->ptr;
    memcpy(base + buffer->used, src, len);
    buffer->used += (uint32_t)len;
    return true;
}

size_t gen_buffer_align_forward(size_t value, size_t alignment) {
    if (alignment < sizeof(void *)) { alignment = sizeof(void *); }
    size_t remainder = value % alignment;
    if (remainder) { value += alignment - remainder; }
    return value;
}

void *gen_buffer_push_aligned(gen_Buffer *buffer, size_t len, size_t alignment) {
    if (!buffer) { return NULL; }
    size_t offset = gen_buffer_align_forward((size_t)buffer->used, alignment);
    size_t end = offset + len;
    if (end > (size_t)buffer->size) { return NULL; }
    uint8_t *base = (uint8_t *)buffer->ptr;
    void *ptr = base + offset;
    buffer->used = (uint32_t)end;
    return ptr;
}

bool gen_buffer_pop_to(gen_Buffer *buffer, uint32_t marker) {
    if (!buffer) { return false; }
    if (marker > buffer->used) { return false; }
    buffer->used = marker;
    return true;
}

bool gen_buffer_read_u8(gen_Buffer *buffer, uint8_t *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_u8(gen_Buffer *buffer, const uint8_t value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_u16(gen_Buffer *buffer, uint16_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (uint16_t)gen__bswap16((uint16_t)*out);
#endif
    return true;
}
bool gen_buffer_write_u16(gen_Buffer *buffer, const uint16_t value) {
#if gen__IS_BIG_ENDIAN
    uint16_t swapped = (uint16_t)gen__bswap16((uint16_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_u32(gen_Buffer *buffer, uint32_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (uint32_t)gen__bswap32((uint32_t)*out);
#endif
    return true;
}
bool gen_buffer_write_u32(gen_Buffer *buffer, const uint32_t value) {
#if gen__IS_BIG_ENDIAN
    uint32_t swapped = (uint32_t)gen__bswap32((uint32_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_u64(gen_Buffer *buffer, uint64_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (uint64_t)gen__bswap64((uint64_t)*out);
#endif
    return true;
}
bool gen_buffer_write_u64(gen_Buffer *buffer, const uint64_t value) {
#if gen__IS_BIG_ENDIAN
    uint64_t swapped = (uint64_t)gen__bswap64((uint64_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_i8(gen_Buffer *buffer, int8_t *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_i8(gen_Buffer *buffer, const int8_t value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_i16(gen_Buffer *buffer, int16_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (int16_t)gen__bswap16((uint16_t)*out);
#endif
    return true;
}
bool gen_buffer_write_i16(gen_Buffer *buffer, const int16_t value) {
#if gen__IS_BIG_ENDIAN
    int16_t swapped = (int16_t)gen__bswap16((uint16_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_i32(gen_Buffer *buffer, int32_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (int32_t)gen__bswap32((uint32_t)*out);
#endif
    return true;
}
bool gen_buffer_write_i32(gen_Buffer *buffer, const int32_t value) {
#if gen__IS_BIG_ENDIAN
    int32_t swapped = (int32_t)gen__bswap32((uint32_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_i64(gen_Buffer *buffer, int64_t *out) {
    if (!gen_buffer_read_bytes(buffer, out, sizeof(*out))) { return false; }
#if gen__IS_BIG_ENDIAN
    *out = (int64_t)gen__bswap64((uint64_t)*out);
#endif
    return true;
}
bool gen_buffer_write_i64(gen_Buffer *buffer, const int64_t value) {
#if gen__IS_BIG_ENDIAN
    int64_t swapped = (int64_t)gen__bswap64((uint64_t)value);
    return gen_buffer_write_bytes(buffer, &swapped, sizeof(swapped));
#else
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
#endif
}

bool gen_buffer_read_f32(gen_Buffer *buffer, float *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_f32(gen_Buffer *buffer, const float value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_f64(gen_Buffer *buffer, double *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_f64(gen_Buffer *buffer, const double value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_read_bool(gen_Buffer *buffer, bool *out) {
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
}
bool gen_buffer_write_bool(gen_Buffer *buffer, const bool value) {
    return gen_buffer_write_bytes(buffer, &value, sizeof(value));
}

bool gen_buffer_skip_bytes(gen_Buffer *buffer, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    buffer->used += (uint32_t)len;
    return true;
}

uint32_t gen_encode_var_u32_raw(uint32_t value, uint8_t out[5]) {
    uint32_t count = 0;
    do {
        uint8_t byte = (uint8_t)(value & 0x7Fu);
        value >>= 7u;
        if (value) { byte |= 0x80u; }
        out[count++] = byte;
    } while (value);
    return count;
}

bool gen_buffer_begin_block(gen_Buffer *buffer, uint32_t *marker) {
    if (buffer->used + 5 > buffer->size) { return false; }
    uint8_t *base = (uint8_t *)buffer->ptr;
    memset(base + buffer->used, 0, 5);
    *marker = buffer->used;
    buffer->used += 5;
    return true;
}

bool gen_buffer_end_block(gen_Buffer *buffer, uint32_t marker) {
    uint32_t payload_start = marker + 5;
    if (buffer->used < payload_start) { return false; }
    uint32_t payload_len = buffer->used - payload_start;
    uint8_t encoded[5];
    uint32_t encoded_len = gen_encode_var_u32_raw(payload_len, encoded);
    uint8_t *base = (uint8_t *)buffer->ptr;
    memmove(base + marker + encoded_len, base + payload_start, payload_len);
    memcpy(base + marker, encoded, encoded_len);
    buffer->used = marker + encoded_len + payload_len;
    return true;
}

bool gen_write_var_u32(gen_Buffer *buffer, uint32_t value);
bool gen_read_var_u32(gen_Buffer *buffer, uint32_t *out);
bool gen_write_var_u64(gen_Buffer *buffer, uint64_t value);
bool gen_read_var_u64(gen_Buffer *buffer, uint64_t *out);
bool gen_write_var_s32(gen_Buffer *buffer, int32_t value);
bool gen_read_var_s32(gen_Buffer *buffer, int32_t *out);
bool gen_write_var_s64(gen_Buffer *buffer, int64_t value);
bool gen_read_var_s64(gen_Buffer *buffer, int64_t *out);

bool gen_buffer_begin_read_block(gen_Buffer *buffer, uint32_t *block_end) {
    if (!block_end) { return false; }
    uint32_t len = 0;
    if (!gen_read_var_u32(buffer, &len)) { return false; }
    if (buffer->used + len > buffer->size) { return false; }
    *block_end = buffer->used + len;
    return true;
}

bool gen_buffer_end_read_block(gen_Buffer *buffer, uint32_t block_end) {
    if (block_end > buffer->size) { return false; }
    if (buffer->used > block_end) { return false; }
    if (buffer->used < block_end) {
        return gen_buffer_skip_bytes(buffer, (size_t)(block_end - buffer->used));
    }
    return true;
}

uint32_t gen_make_wire_tag(uint32_t field_id, gen_wireType wire) {
    return (field_id << 2) | (uint32_t)wire;
}
bool gen_write_wire_tag(gen_Buffer *buffer, uint32_t field_id, gen_wireType wire) {
    return gen_write_var_u32(buffer, gen_make_wire_tag(field_id, wire));
}
bool gen_read_wire_tag(gen_Buffer *buffer, uint32_t *out_field_id, gen_wireType *out_wire) {
    uint32_t raw = 0;
    if (!gen_read_var_u32(buffer, &raw)) { return false; }
    if (raw == 0) { *out_field_id = 0; *out_wire = gen_wireType_Varint; return true; }
    *out_field_id = raw >> 2;
    *out_wire = (gen_wireType)(raw & 0x3u);
    return true;
}

bool gen_skip_wire_value(gen_Buffer *buffer, gen_wireType wire) {
    switch (wire) {
        case gen_wireType_Varint:
        {
            while (true) {
                uint8_t byte = 0;
                if (!gen_buffer_read_u8(buffer, &byte)) { return false; }
                if ((byte & 0x80u) == 0) { break; }
            }
            return true;
        }
        case gen_wireType_Fixed32:
            return gen_buffer_skip_bytes(buffer, 4);
        case gen_wireType_Fixed64:
            return gen_buffer_skip_bytes(buffer, 8);
        case gen_wireType_LengthDelimited:
        {
            uint32_t len = 0;
            if (!gen_read_var_u32(buffer, &len)) { return false; }
            return gen_buffer_skip_bytes(buffer, len);
        }
        default:
            return false;
    }
}

bool gen_buffer_read_string(gen_Buffer *buffer, gen_Buffer *memory, gen_str8 *out) {
    if (!memory) { return false; }
    uint32_t len = 0;
    if (!gen_read_var_u32(buffer, &len)) { return false; }
    if (buffer->used + len > buffer->size) { return false; }
    uint8_t *str = (uint8_t *)gen_buffer_push_aligned(memory, (size_t)len + 1, 1);
    if (!str) { return false; }
    if (!gen_buffer_read_bytes(buffer, str, len)) { return false; }
    str[len] = 0;
    out->content = str;
    out->size = len;
    return true;
}
bool gen_buffer_write_string(gen_Buffer *buffer, const gen_str8 *value) {
    uint64_t len = value ? value->size : 0;
    if (len > UINT32_MAX) { return false; }
    if (!gen_write_var_u32(buffer, (uint32_t)len)) { return false; }
    if (len == 0) { return true; }
    if (!value->content) { return false; }
    return gen_buffer_write_bytes(buffer, value->content, (size_t)len);
}

typedef struct gen_BitWriter {
    uint8_t scratch;
    uint8_t used_bits;
} gen_BitWriter;
typedef struct gen_BitReader {
    uint8_t scratch;
    uint8_t used_bits;
} gen_BitReader;
bool gen_bitwriter_write(gen_BitWriter *bw, gen_Buffer *buffer, uint64_t value, uint32_t width) {
    while (width) {
        uint32_t avail = 8u - bw->used_bits;
        uint32_t take = width < avail ? width : avail;
        uint8_t chunk_mask = (uint8_t)((UINT8_C(1) << take) - 1u);
        bw->scratch |= (uint8_t)((value & chunk_mask) << bw->used_bits);
        bw->used_bits += (uint8_t)take;
        value >>= take;
        width -= take;
        if (bw->used_bits == 8u) {
            if (!gen_buffer_write_u8(buffer, bw->scratch)) { return false; }
            bw->scratch = 0;
            bw->used_bits = 0;
        }
    }
    return true;
}
bool gen_bitwriter_flush(gen_BitWriter *bw, gen_Buffer *buffer) {
    if (bw->used_bits == 0) { return true; }
    bool ok = gen_buffer_write_u8(buffer, bw->scratch);
    bw->scratch = 0;
    bw->used_bits = 0;
    return ok;
}
bool gen_bitreader_read(gen_BitReader *br, gen_Buffer *buffer, uint32_t width, uint64_t *out) {
    uint64_t result = 0;
    uint32_t shift = 0;
    while (width) {
        if (br->used_bits == 8u) {
            if (!gen_buffer_read_u8(buffer, &br->scratch)) { return false; }
            br->used_bits = 0;
        }
        uint32_t avail = 8u - br->used_bits;
        uint32_t take = width < avail ? width : avail;
        uint8_t chunk_mask = (uint8_t)((UINT8_C(1) << take) - 1u);
        uint8_t chunk = (uint8_t)((br->scratch >> br->used_bits) & chunk_mask);
        result |= ((uint64_t)chunk) << shift;
        br->used_bits += (uint8_t)take;
        width -= take;
        shift += take;
    }
    *out = result;
    return true;
}
void gen_bitreader_align(gen_BitReader *br) {
    if (br->used_bits != 0 && br->used_bits < 8u) { br->used_bits = 8u; }
}

uint32_t gen_zigzag32(int32_t value) {
    return ((uint32_t)value << 1) ^ (uint32_t)(value >> 31);
}
int32_t gen_unzigzag32(uint32_t value) {
    return (int32_t)((value >> 1) ^ (~(value & 1) + 1));
}
uint64_t gen_zigzag64(int64_t value) {
    return ((uint64_t)value << 1) ^ (uint64_t)(value >> 63);
}
int64_t gen_unzigzag64(uint64_t value) {
    return (int64_t)((value >> 1) ^ (~(value & 1) + 1));
}

bool gen_write_var_u32(gen_Buffer *buffer, uint32_t value) {
    uint8_t bytes[5];
    uint32_t count = 0;
    do {
        uint8_t byte = (uint8_t)(value & 0x7Fu);
        value >>= 7u;
        if (value) { byte |= 0x80u; }
        bytes[count++] = byte;
    } while (value && count < sizeof(bytes));
    return gen_buffer_write_bytes(buffer, bytes, count);
}
bool gen_read_var_u32(gen_Buffer *buffer, uint32_t *out) {
    uint32_t result = 0;
    uint32_t shift = 0;
    for (uint32_t i = 0; i < 5; ++i) {
        uint8_t byte = 0;
        if (!gen_buffer_read_u8(buffer, &byte)) { return false; }
        result |= ((uint32_t)(byte & 0x7Fu) << shift);
        if ((byte & 0x80u) == 0) { *out = result; return true; }
        shift += 7u;
    }
    return false;
}
bool gen_write_var_u64(gen_Buffer *buffer, uint64_t value) {
    uint8_t bytes[10];
    uint32_t count = 0;
    do {
        uint8_t byte = (uint8_t)(value & 0x7Fu);
        value >>= 7u;
        if (value) { byte |= 0x80u; }
        bytes[count++] = byte;
    } while (value && count < sizeof(bytes));
    return gen_buffer_write_bytes(buffer, bytes, count);
}
bool gen_read_var_u64(gen_Buffer *buffer, uint64_t *out) {
    uint64_t result = 0;
    uint32_t shift = 0;
    for (uint32_t i = 0; i < 10; ++i) {
        uint8_t byte = 0;
        if (!gen_buffer_read_u8(buffer, &byte)) { return false; }
        result |= ((uint64_t)(byte & 0x7Fu) << shift);
        if ((byte & 0x80u) == 0) { *out = result; return true; }
        shift += 7u;
    }
    return false;
}
bool gen_write_var_s32(gen_Buffer *buffer, int32_t value) {
    return gen_write_var_u32(buffer, gen_zigzag32(value));
}
bool gen_read_var_s32(gen_Buffer *buffer, int32_t *out) {
    uint32_t tmp = 0;
    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
    *out = gen_unzigzag32(tmp);
    return true;
}
bool gen_write_var_s64(gen_Buffer *buffer, int64_t value) {
    return gen_write_var_u64(buffer, gen_zigzag64(value));
}
bool gen_read_var_s64(gen_Buffer *buffer, int64_t *out) {
    uint64_t tmp = 0;
    if (!gen_read_var_u64(buffer, &tmp)) { return false; }
    *out = gen_unzigzag64(tmp);
    return true;
}
bool gen_buffer_skip(gen_Buffer *buffer, size_t len) {
    if (buffer->used + len > buffer->size) { return false; }
    buffer->used += (uint32_t)len;
    return true;
}
bool gen_write_field_header(gen_Buffer *buffer, uint32_t field_id, uint32_t type_code) {
    if (!gen_write_var_u32(buffer, field_id)) { return false; }
    if (field_id == 0) { return true; }
    return gen_write_var_u32(buffer, type_code);
}
bool gen_read_field_header(gen_Buffer *buffer, uint32_t *out_field, uint32_t *out_type) {
    if (!gen_read_var_u32(buffer, out_field)) { return false; }
    if (*out_field == 0) { return true; }
    return gen_read_var_u32(buffer, out_type);
}
float gen_denorm_clamp_f32(float value) {
    if (fabsf(value) < FLT_MIN) { return 0.0f; }
    return value;
}
bool gen_write_compact_f32(gen_Buffer *buffer, float value) {
    float normalized = gen_denorm_clamp_f32(value);
    uint8_t flag = normalized == 0.0f ? 0u : 1u;
    if (!gen_buffer_write_u8(buffer, flag)) { return false; }
    if (!flag) { return true; }
#if gen__IS_BIG_ENDIAN
    uint32_t raw; memcpy(&raw, &normalized, 4); raw = gen__bswap32(raw);
    return gen_buffer_write_bytes(buffer, &raw, sizeof(raw));
#else
    return gen_buffer_write_bytes(buffer, &normalized, sizeof(normalized));
#endif
}
bool gen_read_compact_f32(gen_Buffer *buffer, float *out) {
    uint8_t flag = 0;
    if (!gen_buffer_read_u8(buffer, &flag)) { return false; }
    if (!flag) { *out = 0.0f; return true; }
#if gen__IS_BIG_ENDIAN
    uint32_t raw; if (!gen_buffer_read_bytes(buffer, &raw, sizeof(raw))) return false;
    raw = gen__bswap32(raw); memcpy(out, &raw, 4); return true;
#else
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
#endif
}
bool gen_write_compact_f64(gen_Buffer *buffer, double value) {
    double normalized = fabs(value) < DBL_MIN ? 0.0 : value;
    uint8_t flag = normalized == 0.0 ? 0u : 1u;
    if (!gen_buffer_write_u8(buffer, flag)) { return false; }
    if (!flag) { return true; }
#if gen__IS_BIG_ENDIAN
    uint64_t raw; memcpy(&raw, &normalized, 8); raw = gen__bswap64(raw);
    return gen_buffer_write_bytes(buffer, &raw, sizeof(raw));
#else
    return gen_buffer_write_bytes(buffer, &normalized, sizeof(normalized));
#endif
}
bool gen_read_compact_f64(gen_Buffer *buffer, double *out) {
    uint8_t flag = 0;
    if (!gen_buffer_read_u8(buffer, &flag)) { return false; }
    if (!flag) { *out = 0.0; return true; }
#if gen__IS_BIG_ENDIAN
    uint64_t raw; if (!gen_buffer_read_bytes(buffer, &raw, sizeof(raw))) return false;
    raw = gen__bswap64(raw); memcpy(out, &raw, 8); return true;
#else
    return gen_buffer_read_bytes(buffer, out, sizeof(*out));
#endif
}
bool gen_AchievementArray_read(gen_AchievementArray *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    uint32_t count = 0;
    if (!gen_buffer_read_u32(buffer, &count)) { return false; }
    value->items = NULL;
    value->count = 0;
    if (count == 0) { return true; }
    const uint32_t memory_marker = memory->used;
    gen_Achievement *items = (gen_Achievement *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_Achievement), (sizeof(gen_Achievement) > sizeof(void *)) ? sizeof(gen_Achievement) : sizeof(void *));
    if (!items) { return false; }
    for (uint32_t i = 0; i < count; ++i) {
        if (!gen_Achievement_read(&items[i], buffer, memory, schema)) {
            gen_buffer_pop_to(memory, memory_marker);
            return false;
        }
    }
    value->items = items;
    value->count = count;
    return true;
}

bool gen_AchievementArray_write(const gen_AchievementArray *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->count)) { return false; }
    for (uint32_t i = 0; i < value->count; ++i) {
        if (!gen_Achievement_write(&value->items[i], buffer, schema)) { return false; }
    }
    return true;
}

bool gen_StringAchievementPairArray_read(gen_StringAchievementPairArray *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    uint32_t count = 0;
    if (!gen_buffer_read_u32(buffer, &count)) { return false; }
    value->items = NULL;
    value->count = 0;
    if (count == 0) { return true; }
    const uint32_t memory_marker = memory->used;
    gen_StringAchievementPair *items = (gen_StringAchievementPair *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_StringAchievementPair), (sizeof(gen_StringAchievementPair) > sizeof(void *)) ? sizeof(gen_StringAchievementPair) : sizeof(void *));
    if (!items) { return false; }
    for (uint32_t i = 0; i < count; ++i) {
        if (!gen_StringAchievementPair_read(&items[i], buffer, memory, schema)) {
            gen_buffer_pop_to(memory, memory_marker);
            return false;
        }
    }
    value->items = items;
    value->count = count;
    return true;
}

bool gen_StringAchievementPairArray_write(const gen_StringAchievementPairArray *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->count)) { return false; }
    for (uint32_t i = 0; i < value->count; ++i) {
        if (!gen_StringAchievementPair_write(&value->items[i], buffer, schema)) { return false; }
    }
    return true;
}

bool gen_Achievement_read(gen_Achievement *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (!gen_buffer_read_u32(buffer, &value->achievementId)) { return false; }
    return true;
}

bool gen_Achievement_write(const gen_Achievement *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->achievementId)) { return false; }
    return true;
}

bool gen_StringAchievementPair_read(gen_StringAchievementPair *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (!gen_buffer_read_string(buffer, memory, &value->key)) { return false; }
    if (!gen_Achievement_read(&value->value, buffer, memory, schema)) { return false; }
    return true;
}

bool gen_StringAchievementPair_write(const gen_StringAchievementPair *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_string(buffer, &value->key)) { return false; }
    if (!gen_Achievement_write(&value->value, buffer, schema)) { return false; }
    return true;
}

bool gen_Player_read(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (!gen_buffer_read_u32(buffer, &value->id)) { return false; }
    if (!gen_AchievementArray_read(&value->colors, buffer, memory, schema)) { return false; }
    if (!gen_StringAchievementPairArray_read(&value->achievements, buffer, memory, schema)) { return false; }
    return true;
}

bool gen_Player_write(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_u32(buffer, value->id)) { return false; }
    if (!gen_AchievementArray_write(&value->colors, buffer, schema)) { return false; }
    if (!gen_StringAchievementPairArray_write(&value->achievements, buffer, schema)) { return false; }
    return true;
}

static const gen_ParameterInfo gen_Achievement_parameters[] = {
    { "achievementId", gen_achievementParameters_achievementId, gen_type_u32, offsetof(gen_Achievement, achievementId) },
};

static const gen_ParameterInfo gen_StringAchievementPair_parameters[] = {
    { "key", gen_stringAchievementPairParameters_key, gen_type_string, offsetof(gen_StringAchievementPair, key) },
    { "value", gen_stringAchievementPairParameters_value, gen_type_Achievement, offsetof(gen_StringAchievementPair, value) },
};

static const gen_ParameterInfo gen_Player_parameters[] = {
    { "id", gen_playerParameters_id, gen_type_u32, offsetof(gen_Player, id) },
    { "colors", gen_playerParameters_colors, gen_type_ArrayAchievement, offsetof(gen_Player, colors) },
    { "achievements", gen_playerParameters_achievements, gen_type_ArrayStringAchievementPair, offsetof(gen_Player, achievements) },
};

static const gen_TypeDescription gen_type_descriptions[] = {
    { "Achievement", gen_type_Achievement, sizeof(gen_Achievement), sizeof(gen_Achievement), gen_Achievement_parameters, 1 },
    { "StringAchievementPair", gen_type_StringAchievementPair, sizeof(gen_StringAchievementPair), sizeof(gen_StringAchievementPair), gen_StringAchievementPair_parameters, 2 },
    { "Player", gen_type_Player, sizeof(gen_Player), sizeof(gen_Player), gen_Player_parameters, 3 },
};

const gen_TypeDescription *gen_get_type_description(gen_type type_id) {
    for (size_t i = 0; i < sizeof(gen_type_descriptions)/sizeof(gen_type_descriptions[0]); ++i) {
        if (gen_type_descriptions[i].type_id == type_id) { return &gen_type_descriptions[i]; }
    }
    return NULL;
}
bool gen_Achievement_encode_compact(const gen_Achievement *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_write_var_u32(buffer, (uint32_t)value->achievementId)) { return false; }
    return true;
}

bool gen_Achievement_decode_compact(gen_Achievement *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (schema) {
        const gen_SchemaType *type = NULL;
        for (uint32_t i = 0; i < schema->type_count; ++i) {
            if (strcmp(schema->types[i].name, "Achievement") == 0) {
                type = &schema->types[i];
                break;
            }
        }
        if (!type) return false;
        uint32_t optional_count = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            if (type->fields[i].is_optional) optional_count++;
        }
        uint8_t mask_buf[128];
        uint8_t *bitmask = NULL;
        if (optional_count > 0) {
            uint32_t bytes = (optional_count + 7) / 8;
            if (bytes > sizeof(mask_buf)) return false;
            if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
            bitmask = mask_buf;
        }
        uint32_t opt_idx = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            bool present = true;
            if (type->fields[i].is_optional) {
                present = (bitmask[opt_idx / 8] >> (opt_idx % 8)) & 1;
                opt_idx++;
            }
            if (!present) continue;
            switch (type->fields[i].mapping) {
                case gen_achievementParameters_achievementId: {
                    {
                        uint32_t tmp = 0;
                        if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                        value->achievementId = (uint32_t)tmp;
                    }
                    break;
                }
                default:
                    if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
                    break;
            }
        }
        return true;
    }

    {
        uint32_t tmp = 0;
        if (!gen_read_var_u32(buffer, &tmp)) { return false; }
        value->achievementId = (uint32_t)tmp;
    }
    return true;
}

bool gen_Achievement_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_wireType wire = gen_wireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

bool gen_StringAchievementPair_encode_compact(const gen_StringAchievementPair *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (!gen_buffer_write_string(buffer, &value->key)) { return false; }
    if (!gen_Achievement_encode_compact(&value->value, buffer, schema)) { return false; }
    return true;
}

bool gen_StringAchievementPair_decode_compact(gen_StringAchievementPair *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    if (schema) {
        const gen_SchemaType *type = NULL;
        for (uint32_t i = 0; i < schema->type_count; ++i) {
            if (strcmp(schema->types[i].name, "StringAchievementPair") == 0) {
                type = &schema->types[i];
                break;
            }
        }
        if (!type) return false;
        uint32_t optional_count = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            if (type->fields[i].is_optional) optional_count++;
        }
        uint8_t mask_buf[128];
        uint8_t *bitmask = NULL;
        if (optional_count > 0) {
            uint32_t bytes = (optional_count + 7) / 8;
            if (bytes > sizeof(mask_buf)) return false;
            if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
            bitmask = mask_buf;
        }
        uint32_t opt_idx = 0;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            bool present = true;
            if (type->fields[i].is_optional) {
                present = (bitmask[opt_idx / 8] >> (opt_idx % 8)) & 1;
                opt_idx++;
            }
            if (!present) continue;
            switch (type->fields[i].mapping) {
                case gen_stringAchievementPairParameters_key: {
                    if (!gen_buffer_read_string(buffer, memory, &value->key)) { return false; }
                    break;
                }
                case gen_stringAchievementPairParameters_value: {
                    if (!gen_Achievement_decode_compact(&value->value, buffer, memory, schema)) { return false; }
                    break;
                }
                default:
                    if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
                    break;
            }
        }
        return true;
    }

    if (!gen_buffer_read_string(buffer, memory, &value->key)) { return false; }
    if (!gen_Achievement_decode_compact(&value->value, buffer, memory, NULL)) { return false; }
    return true;
}

bool gen_StringAchievementPair_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_wireType wire = gen_wireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

bool gen_Player_encode_compact(const gen_Player *value, gen_Buffer *buffer, const gen_SchemaInfo *schema) {
    (void)schema;
    if (true) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_id, gen_wireType_Varint)) { return false; }
        if (!gen_write_var_u32(buffer, (uint32_t)value->id)) { return false; }
    }
    if (value->colors.count > 0) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_colors, gen_wireType_LengthDelimited)) { return false; }
        uint32_t block_marker = 0;
        if (!gen_buffer_begin_block(buffer, &block_marker)) { return false; }
        if (!gen_write_var_u32(buffer, value->colors.count)) { return false; }
        for (uint32_t i = 0; i < value->colors.count; ++i) {
            if (!gen_Achievement_encode_compact(&value->colors.items[i], buffer, schema)) { return false; }
        }
        if (!gen_buffer_end_block(buffer, block_marker)) { return false; }
    }
    if (value->achievements.count > 0) {
        if (!gen_write_wire_tag(buffer, gen_playerParameters_achievements, gen_wireType_LengthDelimited)) { return false; }
        uint32_t block_marker = 0;
        if (!gen_buffer_begin_block(buffer, &block_marker)) { return false; }
        if (!gen_write_var_u32(buffer, value->achievements.count)) { return false; }
        for (uint32_t i = 0; i < value->achievements.count; ++i) {
            if (!gen_StringAchievementPair_encode_compact(&value->achievements.items[i], buffer, schema)) { return false; }
        }
        if (!gen_buffer_end_block(buffer, block_marker)) { return false; }
    }
    if (!gen_write_var_u32(buffer, 0)) { return false; }
    return true;
}

bool gen_Player_decode_compact(gen_Player *value, gen_Buffer *buffer, gen_Buffer *memory, const gen_SchemaInfo *schema) {
    if (!memory) { return false; }
    memset(value, 0, sizeof(*value));
    while (true) {
        uint32_t field_id = 0;
        gen_wireType wire = gen_wireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        switch (field_id) {
            case gen_playerParameters_id: {
                {
                    uint32_t tmp = 0;
                    if (!gen_read_var_u32(buffer, &tmp)) { return false; }
                    value->id = (uint32_t)tmp;
                }
                break;
            }
            case gen_playerParameters_colors: {
                if (wire != gen_wireType_LengthDelimited) { return false; }
                uint32_t block_end = 0;
                if (!gen_buffer_begin_read_block(buffer, &block_end)) { return false; }
                uint32_t count = 0;
                if (!gen_read_var_u32(buffer, &count)) { return false; }
                value->colors.items = NULL;
                value->colors.count = 0;
                if (count) {
                    const uint32_t memory_marker = memory->used;
                    gen_Achievement *items = (gen_Achievement *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_Achievement), (sizeof(gen_Achievement) > sizeof(void *)) ? sizeof(gen_Achievement) : sizeof(void *));
                    if (!items) { return false; }
                    for (uint32_t i = 0; i < count; ++i) {
                        if (!gen_Achievement_decode_compact(&items[i], buffer, memory, schema)) {
                            gen_buffer_pop_to(memory, memory_marker);
                            return false;
                        }
                    }
                    value->colors.items = items;
                    value->colors.count = count;
                }
                if (!gen_buffer_end_read_block(buffer, block_end)) { return false; }
                break;
            }
            case gen_playerParameters_achievements: {
                if (wire != gen_wireType_LengthDelimited) { return false; }
                uint32_t block_end = 0;
                if (!gen_buffer_begin_read_block(buffer, &block_end)) { return false; }
                uint32_t count = 0;
                if (!gen_read_var_u32(buffer, &count)) { return false; }
                value->achievements.items = NULL;
                value->achievements.count = 0;
                if (count) {
                    const uint32_t memory_marker = memory->used;
                    gen_StringAchievementPair *items = (gen_StringAchievementPair *)gen_buffer_push_aligned(memory, (size_t)count * sizeof(gen_StringAchievementPair), (sizeof(gen_StringAchievementPair) > sizeof(void *)) ? sizeof(gen_StringAchievementPair) : sizeof(void *));
                    if (!items) { return false; }
                    for (uint32_t i = 0; i < count; ++i) {
                        if (!gen_StringAchievementPair_decode_compact(&items[i], buffer, memory, schema)) {
                            gen_buffer_pop_to(memory, memory_marker);
                            return false;
                        }
                    }
                    value->achievements.items = items;
                    value->achievements.count = count;
                }
                if (!gen_buffer_end_read_block(buffer, block_end)) { return false; }
                break;
            }
            default:
                if (!gen_skip_wire_value(buffer, wire)) { return false; }
                break;
        }
    }
    return true;
}

bool gen_Player_skip_compact(gen_Buffer *buffer) {
    while (true) {
        uint32_t field_id = 0;
        gen_wireType wire = gen_wireType_Varint;
        if (!gen_read_wire_tag(buffer, &field_id, &wire)) { return false; }
        if (field_id == 0) { break; }
        if (!gen_skip_wire_value(buffer, wire)) { return false; }
    }
    return true;
}

#define gen_BINARY_MAGIC "BKIW"
#define gen_BINARY_VERSION 4

const uint8_t gen_schema_blob[] = {

    0x42, 0x4b, 0x49, 0x57, 0x04, 0x03, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 
    0x74, 0x00, 0x01, 0x0c, 0x01, 0x61, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 
    0x49, 0x64, 0x00, 0x00, 0x02, 0x00, 0x00, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x41, 0x63, 0x68, 
    0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x61, 0x69, 0x72, 0x00, 0x01, 0x0d, 0x02, 
    0x6b, 0x65, 0x79, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x00, 0x01, 0x0c, 
    0x00, 0x00, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x00, 0x02, 0x0e, 0x03, 0x69, 0x64, 0x00, 0x01, 
    0x02, 0x00, 0x00, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 0x00, 0x04, 0x0c, 0x01, 0x00, 0x61, 0x63, 
    0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x00, 0x08, 0x0d, 0x01, 0x00, 
};

static const char *gen_read_strz(const uint8_t **cursor, const uint8_t *end) {
    const char *str = (const char *)*cursor;
    while (*cursor < end && **cursor != 0) { (*cursor)++; }
    if (*cursor < end) { (*cursor)++; return str; }
    return "";
}

static uint64_t gen_read_varuint(const uint8_t **cursor, const uint8_t *end) {
    uint64_t result = 0;
    uint32_t shift = 0;
    while (*cursor < end) {
        uint8_t byte = *(*cursor)++;
        result |= ((uint64_t)(byte & 0x7F) << shift);
        if ((byte & 0x80) == 0) { break; }
        shift += 7;
    }
    return result;
}

const gen_SchemaInfo *gen_parse_schema(const uint8_t *data, size_t size, gen_Buffer *allocator) {
    if (!data || !allocator) return NULL;
    const uint8_t *cursor = data;
    const uint8_t *end = data + size;
    if (size < 5 || memcmp(cursor, gen_BINARY_MAGIC, 4) != 0) return NULL;
    cursor += 4;
    uint8_t version = *cursor++;
    if (version != gen_BINARY_VERSION && version != 2 && version != 3) return NULL;
    
    uint64_t count = gen_read_varuint(&cursor, end);
    gen_SchemaInfo *info = (gen_SchemaInfo *)gen_buffer_push_aligned(allocator, sizeof(gen_SchemaInfo), sizeof(void*));
    if (!info) return NULL;
    info->version = version;
    info->type_count = (uint32_t)count;
    info->types = (gen_SchemaType *)gen_buffer_push_aligned(allocator, sizeof(gen_SchemaType) * count, sizeof(void*));
    if (!info->types) return NULL;
    
    for (uint32_t i = 0; i < count; ++i) {
        gen_SchemaType *type = &info->types[i];
        type->name = gen_read_strz(&cursor, end);
        type->kind = *cursor++;
        type->type_id = (uint32_t)gen_read_varuint(&cursor, end);
        if (type->kind == 3 && version >= 4) {
            type->tag_type_id = (uint32_t)gen_read_varuint(&cursor, end);
        } else {
            type->tag_type_id = 0;
        }
        uint64_t fcount = gen_read_varuint(&cursor, end);
        type->field_count = (uint32_t)fcount;
        if (fcount > 0) {
            type->fields = (gen_SchemaField *)gen_buffer_push_aligned(allocator, sizeof(gen_SchemaField) * fcount, sizeof(void*));
            if (!type->fields) return NULL;
            for (uint32_t j = 0; j < fcount; ++j) {
                type->fields[j].name = gen_read_strz(&cursor, end);
                type->fields[j].id = (uint32_t)gen_read_varuint(&cursor, end);
                type->fields[j].type_id = (uint32_t)gen_read_varuint(&cursor, end);
                uint8_t flags = *cursor++;
                type->fields[j].bit_width = (uint32_t)gen_read_varuint(&cursor, end);
                type->fields[j].is_array = (flags & 1) != 0;
                type->fields[j].is_optional = (flags & 2) != 0;
                type->fields[j].is_deprecated = (flags & 4) != 0;
                type->fields[j].is_removed = (flags & 8) != 0;
                type->fields[j].mapping = -1;
            }
        } else {
            type->fields = NULL;
        }
    }
    
    // Resolve schema against local types
    for (uint32_t i = 0; i < info->type_count; ++i) {
        gen_SchemaType *type = &info->types[i];
        const gen_TypeDescription *desc = NULL;
        for (size_t j = 0; j < sizeof(gen_type_descriptions)/sizeof(gen_type_descriptions[0]); ++j) {
            if (strcmp(gen_type_descriptions[j].name, type->name) == 0) {
                desc = &gen_type_descriptions[j];
                break;
            }
        }
        if (!desc) continue;
        
        for (uint32_t j = 0; j < type->field_count; ++j) {
            gen_SchemaField *field = &type->fields[j];
            if (field->is_removed) continue;
            for (uint32_t k = 0; k < desc->parameter_count; ++k) {
                if (strcmp(desc->parameters[k].name, field->name) == 0) {
                    field->mapping = (int32_t)desc->parameters[k].parameter_id;
                    break;
                }
            }
        }
    }
    return info;
}

const uint8_t *gen_get_schema_blob(size_t *out_size) {
    if (out_size) { *out_size = sizeof(gen_schema_blob); }
    return gen_schema_blob;
}

const gen_SchemaInfo *gen_get_embedded_schema(gen_Buffer *allocator) {
    return gen_parse_schema(gen_schema_blob, sizeof(gen_schema_blob), allocator);
}

bool gen_skip_generic(gen_Buffer *buffer, uint32_t type_id, bool is_array, const gen_SchemaInfo *schema) {
    if (is_array) {
        uint32_t count = 0;
        if (!gen_read_var_u32(buffer, &count)) return false;
        for (uint32_t i = 0; i < count; ++i) {
            if (!gen_skip_generic(buffer, type_id, false, schema)) return false;
        }
        return true;
    }
    // Builtins
    if (type_id < 11) {
        switch (type_id) {
            case 0: // u8
            case 4: // i8
            case 10: // bool
                return gen_buffer_skip_bytes(buffer, 1);
            case 1: // u16
            case 2: // u32
            case 5: // i16
            case 6: // i32
            {
                uint32_t tmp; return gen_read_var_u32(buffer, &tmp);
            }
            case 3: // u64
            case 7: // i64
            {
                uint64_t tmp; return gen_read_var_u64(buffer, &tmp);
            }
            case 8: // f32
            {
                float tmp; return gen_read_compact_f32(buffer, &tmp);
            }
            case 9: // f64
            {
                double tmp; return gen_read_compact_f64(buffer, &tmp);
            }
        }
        return false;
    }
    // Look up in schema
    if (!schema) return false;
    const gen_SchemaType *type = NULL;
    for (uint32_t i = 0; i < schema->type_count; ++i) {
        if (schema->types[i].type_id == type_id) {
            type = &schema->types[i];
            break;
        }
    }
    if (!type) return false;
    
    if (type->kind == 0) { // ENUM
        uint32_t tmp; return gen_read_var_u32(buffer, &tmp);
    }
    
    if (type->kind == 3) { // UNION
        uint32_t tag = 0;
        if (!gen_read_var_u32(buffer, &tag)) return false;
        const gen_SchemaField *field = NULL;
        for (uint32_t i = 0; i < type->field_count; ++i) {
            if (type->fields[i].id == tag) { field = &type->fields[i]; break; }
        }
        if (!field) { return false; }
        return gen_skip_generic(buffer, field->type_id, field->is_array, schema);
    }
    
    // STRUCT or MESSAGE
    if (type->kind == 2) { // MESSAGE
        // Messages are length-delimited; skip fields until the terminator tag.
        while (true) {
            uint32_t field_id = 0;
            gen_wireType wire = gen_wireType_Varint;
            if (!gen_read_wire_tag(buffer, &field_id, &wire)) return false;
            if (field_id == 0) break;
            if (!gen_skip_wire_value(buffer, wire)) return false;
        }
        return true;
    }
    
    // STRUCT
    // Read bitmask for optional fields
    uint32_t optional_count = 0;
    bool has_bitfields = false;
    for (uint32_t i = 0; i < type->field_count; ++i) {
        if (type->fields[i].is_removed) continue;
        if (type->fields[i].is_optional) optional_count++;
        if (type->fields[i].bit_width > 0) has_bitfields = true;
    }
    gen_BitReader bit_reader = {0, 8};
    uint8_t *bitmask = NULL;
    if (optional_count > 0) {
        uint32_t bytes = (optional_count + 7) / 8;
        if (bytes > 128) return false;
        uint8_t mask_buf[128];
        if (!gen_buffer_read_bytes(buffer, mask_buf, bytes)) return false;
        bitmask = mask_buf;
    }
    
    uint32_t opt_idx = 0;
    for (uint32_t i = 0; i < type->field_count; ++i) {
        if (type->fields[i].is_removed) continue;
        bool present = true;
        if (type->fields[i].is_optional) {
            present = (bitmask[opt_idx / 8] >> (opt_idx        )) & 1;
            opt_idx++;
        }
        if (has_bitfields && type->fields[i].bit_width == 0) { gen_bitreader_align(&bit_reader); }
        if (present) {
            if (type->fields[i].bit_width > 0) {
                uint64_t tmp = 0;
                if (!gen_bitreader_read(&bit_reader, buffer, type->fields[i].bit_width, &tmp)) return false;
            } else if (!gen_skip_generic(buffer, type->fields[i].type_id, type->fields[i].is_array, schema)) return false;
        }
    }
    return true;
}

#endif /* GEN__IMPLEMENTATION */
